\section{Model and Definitions}
\label{sec:model}
Our model is based on the ``backbone'' model for proof-of-work
cryptocurrencies~\cite{backbone}, extended with SPV. Following their model, we
assume \emph{synchrony}
and constant difficulty. We discuss an extension to the variable difficulty and the \emph{bounded delay} setting~\cite{pass-asynchronous} in the next chapter.

\todo{Move the following to preliminaries}

\noindent
\textbf{Backbone model.}
% AM:
%We define our problem in the setting of a blockchain client which is completely
%stateless beyond the knowledge of a common reference string, the genesis block.
%Without loss of generality, this single reference block could be any stable
%checkpoint block, either hard-coded in the client or obtained through a previous
%interaction with the network.
The entities on the blockchain network are of 3 kinds: (1) Miners, who try to
mine new blocks on top of the longest known blockchain and broadcast them as
soon as they are discovered. Miners commit new transactions they receive from clients. (2) Full nodes, who maintain the longest blockchain
without mining and also act as the provers in the network. (3) Verifiers or
stateless clients, who do not store the entire blockchain, but instead connect to provers and ask for proofs in regards to which
blockchain is the largest. The verifiers attempt to determine the value of a
predicate on these chains, for example whether a particular payment has been finalized.

Our main challenge is to design
a protocol so that clients can sieve through  the responses they receive from
the network and reach a conclusion that should never disagree with the
conclusion of a full  node who is faced with the same objective and infers it
from its local blockchain state.

Blockchain blocks are generated by including the following data in them: $ctr$,
the nonce used to achieve the proof-of-work; $x$ the Merkle tree~\cite{merkle}
root of the transactions confirmed in this block; and
\emph{interlink}~\cite{popow}, a vector containing pointers to previous blocks,
including the id of the previous block. The \emph{interlink} data structure
contains pointers to more blocks than just the previous block. We will explain
this further in Section~\ref{sec:consensus}. Given two hash functions $H$ and
$G$ modelled as random oracles, the id of a block is defined as $\textsf{id} =
H(ctr, G(x, \textsf{interlink}))$. In bitcoin's case, both $H$ and $G$ would be
SHA256.

\noindent
\textbf{The prover and verifier model.}
In our protocol, the nodes include a \emph{proof} along with their responses to
clients. We need to assume that clients are able to connect to at least one
correctly functioning node (i.e., that they cannot be eclipsed from the
network~\cite{eclipse,hijackingbitcoin}). Each client makes the same
request to every node, and by verifying the proofs the client identifies the
correct response. Henceforth we will call clients \emph{verifiers} and nodes
\emph{provers}.
% Note that in the interactive protocol from prior
% work~\cite{popow},  the prover and verifier may engage in more than one round of
% message passing.

The prover-verifier interaction is parameterized by a predicate (e.g. ``the
transaction $tx$ is committed in the blockchain'').
%
The predicates of interest in our context are predicates on the active
blockchain. Some of the predicates are more suitable for succinct proofs than
others. We focus our attention in \emph{stable} predicates having the property
that all honest miners share their view of them in a way that is updated in a
predictable manner, with a truth-value that persists as the blockchain grows (an
example of an unstable predicate is e.g., the least significant bit of the hash
of last block). Following the work of \cite{backbone}, we wait for $k$ blocks to
bury a block before we consider it \emph{confirmed} and thereby the predicates
depending on it stable. $k$ is the \emph{common prefix} security parameter,
which in Bitcoin folklore is often taken to be $k = 6$.

In our setting, for a given predicate $Q$, several  provers (including
adversarial ones) will generate proofs claiming potentially different truth
values for $Q$ based on their claimed local longest chains. The verifier
receives these proofs and accepts one of the proofs, determining the truth value
of the predicate.  We denote a  \emph{blockchain proof protocol} for a
predicate $Q$ as a pair $(P, V)$ where $P$ is the \emph{prover} and $V$ is the
\emph{verifier}. $P$ is a PPT algorithm that is spawned by a full node when
they wish to produce a proof, accepts as input a full chain $\chain$ and
produces a proof $\pi$ as its output. $V$ is a PPT algorithm which is spawned at
some round (having only Genesis), receives a pair of proofs $(\pi_A, \pi_B)$
from both an honest party and the adversary and returns its decision $d \in \{T,
F\}$ before the next round and terminates. The honest miners produce proofs for
$V$ using $P$, while the adversary produces proofs following some arbitrary
strategy. Before we introduce the security properties for blockchain proof
protocols we introduce some necessary notation for blockchains.
