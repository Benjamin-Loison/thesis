\subsection{Preliminaries}

\todo{Merge section with background chapter}

%% AK: the below is not needed as it is captured by DDifuse.
%\subsubsection{Restrictions imposed on the environment}
%
%We assume that the execution satisfies the following conditions:
%  (a) At each slot $\slot_j$, the environment $\env$  activates
%  all honest parties.
%  (b) The adversary is activated at least as the last entity in each $\slot_j$
%  (as well as during all adversarial party activations and invocations
%  from the ideal functionalities as prescribed).
  %(c) If a stakeholder does not fetch in a certain slot
  %the messages written to its incoming string from the diffuse functionality
  %they are flushed.

Clearly, the above model is by itself too strong to allow us to prove  any meaningful security
guarantees for the executed protocol without further restrictions (as it, for
example, does not prevent the adversary from corrupting all the participating
parties). Therefore, in what follows, we will consider such additional
assumptions, and will only
provide security guarantees as long as such assumptions are satisfied.
These assumptions will be specific to the protocol in consideration, and will be an
explicit part of our statements.\footnote{As an example, we will be assuming that a
majority of a certain pool of stake is controlled by uncorrupted parties.}
%Formally, such assumptions can be captured by putting restrictions on the class
%of admissible environments~$\env$, as done in previous
%works~\cite{C:KRDO17,EC:DGKR18}.


%It is easy to see that the model above confers such sweeping power on
%the adversary that one cannot establish any significant guarantees on
%protocols of interest.  It is thus important to restrict the
%environment suitably (taking into account the details of the protocol) so
%that we may be able to argue security.
%We require that in every slot, the adversary does not control more than $50\%$
%of the stake in the view of any honest stakeholder.
%This transaction data, including the required signatures by each stakeholder, is obtained by the environment as specified in the protocol.
%If this is violated, an event $\mathsf{Bad}^{\frac{1}{2}}$ becomes true for the
%given execution.
%When the environment spawns a new stakeholder by sending message $(\mathsf{Create},U,\chain)$ to the Key and Transaction functionality,
%the initial local chain $\chain$ can be the chain of any honest stakeholder even in the case of ``lazy honest'' stakeholders as described in Appendix~\ref{app:lazy},
%without requiring this stakeholder to have been online in the past slot as in~\cite{C:KRDO17}.
%Finally,
%we note that in all our proofs, whenever we say that a property $Q$ holds with high
%probability over all executions,
%we will in fact argue that $Q \lor {\sf Bad}^{\frac{1}{2}}$ holds with high probability
%over all executions. This  captures the fact that we exclude environments and adversaries
%that trigger ${\sf Bad}^{\frac{1}{2}}$ with non-negligible probability.



\subsection{Blockchains and Ledgers}
A \emph{blockchain} (or a \emph{chain}) (denoted e.g. $\Chain$)  is a sequence
of blocks where each one is connected to the previous one by containing its
hash.

Blockchains (and in general, any sequences) are indexed using bracket notation.
$\Chain[i]$ indicates the $i^{\text{th}}$ block, starting from $\Chain[0]$, the
genesis block. $\Chain[-i]$ indicates the $i^{\text{th}}$ block from the end,
with $\Chain[-1]$ being the tip of the blockchain. $\Chain[i:j]$ indicates a
subsequence, or \emph{subchain} of the blockchain starting from block $i$
(inclusive) and ending at block $j$ (exclusive). Any of these two indices can be
negative. Omitting one of the two indexes in the range addressing takes the
subsequence to the beginning or the end of the blockchain, respectively. Given
blocks $A$ and $Z$ in $\Chain$, we let $\Chain\{A:Z\}$ denotes the subchain
obtained by only keeping the blocks from $A$ (inclusive) to $Z$ (exclusive).
Again any of these two blocks can be omitted to indicate a subchain from the
beginning or to the end of the blockchain, respectively. In blockchain
protocols, each honest party $\party$ maintains a currently adopted chain. We
denote $\LView{\Chain}{\party}{t}$ the chain adopted by party $\party$ at slot~$t$.

A \emph{ledger} (denoted in bold-face, e.g. $\Ledger$) is a mechanism for
maintaining a sequence of transactions, often stored in the form of a
blockchain.  In this paper, we slightly abuse the language by letting $\Ledger$
(without further qualifiers) interchangeably refer to the algorithms used to
maintain the sequence, and all the views of the participants of the state of
these algorithms when being executed.  For example, the (existing) ledger
Bitcoin consists of the set of all transactions that ever took place in the
Bitcoin network, %the Bitcoin protocol,
the current UTXO set, as well as the
local views of all the participants.

In contrast, we call a \emph{ledger state}
%$\LState$
a concrete sequence of transactions
$\tx_1,\tx_2, \ldots$ stored in the \emph{stable} part of a ledger $\Ledger$, typically as viewed by a
particular party.
Hence, in every blockchain-based ledger $\Ledger$, every fixed
chain $\Chain$ defines a concrete ledger state % $\LState$
by applying  the interpretation rules given as a part of the description
of~$\Ledger$ (for example, the ledger state is obtained from the
blockchain by dropping the last $k$ blocks and serializing the transactions in
the remaining blocks).
We maintain the typographic convention that a ledger state (e.g. $\LState$) always
belongs to the bold-face ledger of the same name (e.g. $\Ledger$).
We denote by $\LView{\Ledger}{P}{t}$ the ledger state of a ledger $\Ledger$ as viewed by a party
$\party$ at the beginning of a time slot $t$,
%Finally, recall that a transaction is called \emph{stable} if it is contained in a block
%at least $k$ blocks away from the end of the blockchain. For a blockchain
%$\Chain$, we denote by $\stable{\Chain}$ the stable part of $\Chain$ (which
%implicitly depends on $k$). Moreover, for a  chain $\Ledger$ we
%denote by $\Ledger^t$ its form in some past time slot $t$.
and by $\check{\Ledger}^P[t]$ the complete state of the ledger (at time
$t$) including all
pending transactions that are not stable yet.
For two ledger states (or, more generally, any sequences), we denote by
$\preceq$ the prefix relation.

Recall the definitions of persistence and liveness of a robust public
transaction ledger given in the most recent version of~\cite{EC:GarKiaLeo15}:

\begin{description}
  \item[Persistence.]
    For any two honest parties $\party_1,\party_2$ and two time slots $t_1\leq t_2$,
    it holds  $\LView{\Ledger}{\party_1}{t_1} \preceq
    \LView{\check{\Ledger}}{\party_2}{t_2}$.

  \item[Liveness.]
    If all honest parties in the system attempt to include a  transaction
    then, at any slot $t$ after $u$ slots (called the
    liveness parameter), any honest party $\party$, if queried,
    will report $\tx \in \LView{\Ledger}{\party}{t}$.
\end{description}

For a ledger $\Ledger$ that satisfies persistence at time $t$, we denote by $\LView{\Ledger}{\cup}{t}$ (resp.
$\LView{\Ledger}{\cap}{t}$) the sequence of transactions that are seen as
included in the ledger by \emph{at least one} (resp., \emph{all}) of the honest
parties. Finally, $\length(\Ledger)$ denotes the length of the ledger $\Ledger$,
i.e., the number of transactions it contains.


\subsection{Underlying Proof-of-Stake Protocols}
\label{sec:ouroboros}
\label{sec:pos}

For conciseness we present our construction on a generic PoS protoocol
 based on  Ouroboros PoS \cite{C:KRDO17}. As we outline
in Appendix~\ref{app:other}, our construction can  be easily adapted to other
provably secure proof-of-stake protocols: Ouroboros
Praos~\cite{EC:DGKR18}, Ouroboros Genesis~\cite{genesis}, Snow
White~\cite{DBLP:journals/iacr/BentovPS16a}, and Algorand~\cite{algorand}.
