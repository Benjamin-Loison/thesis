\subsection{Security of Sidechains}
\label{sec:security}

In this section we give a formal argument
establishing that the
%validity language $\adalang$ is correct according to
%Definition~\ref{def:correctness} and the
construction from Section~\ref{sec:construction} achieves
%pegging correctness and
pegging security of
Definition~\ref{def:security}.

\subsubsection{Assumptions}

Let $\Assum_{\hm}(\Ledger)[t]$ denote the honest-majority assumption for an
Ouroboros ledger $\Ledger$. Namely, $\Assum_{\hm}(\Ledger)[t]$ postulates that
in all slots $t' \leq t$, the majority of stake in the stake distribution used to
sample the slot leader for slot $t'$ in $\Ledger$ is controlled by honest parties
(note that the distribution in question is $\SD$ and $\SDb^*$ for $\Mainchain$ and
$\Sidechain$, respectively).
Specifically, the adversary is restricted to $(1 - \epsilon)/{2}$ relative stake
for some fixed $\epsilon>0$.
% PG: we never use this epsilon again.

The assumption $\Assum_\Mainchain$ we consider for $\Mainchain$
is precisely $\Assum_\Mainchain[t]\defeq\Assum_{\hm}(\Mainchain)[t]$, while the assumption $\Assum_\Sidechain$ for $\Sidechain$ is
$\Assum_\Sidechain[t]\defeq\Assum_\Mainchain[t]\land\Assum_{\hm}(\Sidechain)[t]$. The reason that
$\Assum_\Sidechain[t]\Rightarrow\Assum_\Mainchain[t]$ is that $\Sidechain$ uses merged staking and hence
cannot provide any security guarantees if the stake records on $\Mainchain$ get
corrupted. It is worth noting that it is possible to program $\Sidechain$ to wean off
$\Mainchain$ and switch to independent staking; in such case the assumption for $\Sidechain$
will transition to $\Assum_{\hm}(\Sidechain)$ (now with respect to $\SDb$) after the
weaning slot and the two chains will become sidechains of each other.

\begin{remark}
    We note that the assumption of honest majority in the distribution out of
    which leaders are \emph{sampled} is one of two related ways of stating
    this requirement. The distribution from which sampling is performed
    corresponds to the actual stake distribution near the end of the previous
    epoch. Hence, the actual stake may have since shifted and may no longer be
    honest. Had we wanted to formulate this assumption in terms of the actual
    (current) stake distribution, we would have to state two different
    assumptions: (1) that the current actual stake has honest majority with some
    gap $\sigma$; and (2) that the rate of stake shifting is bounded by $\sigma$
    for the duration of (roughly) 2 epochs.  From these two assumptions, one can
    conclude that the distribution from which leaders are elected is currently
    controlled by an honest majority.  The latter approach was taken for example
    in~\cite{ouroboros}.
\end{remark}

\subsubsection{Proof Overview}

Proving our construction secure requires some case analysis. We summarize the
intuition behind this endeavour before we proceed with the formal treatment.

The proof of Theorem~\ref{thm:security} that shows that
our construction from Section~\ref{sec:construction} has pegging security with overwhelming probability will be
established as follows. We will borrow the fact that our construction achieves
persistence and liveness
from the original analysis~\cite{ouroboros} and state
them as Lemma~\ref{lem:perslive}. The main challenge will
be to establish the firewall property, which is done in
Lemma~\ref{lem:firewall}. These properties together establish pegging
security as required by Definition~\ref{def:security}.

To show that the firewall property holds, we
perform a case analysis, looking at
the two cases of interest: when both $\Mainchain$ and
$\Sidechain$ are secure (i.e., when $\Assum_\Mainchain\land\Assum_\Sidechain$ holds), and when only $\Mainchain$ is secure while the security assumption of
$\Sidechain$ has been violated.
As discussed above, the case where $\Sidechain$ is secure and
the security of $\Mainchain$ has been violated cannot occur per definition of
$\Assum_\Mainchain$ and $\Assum_\Sidechain$, and so examining this
case is not necessary.

First, we examine the case where both $\Mainchain$ and $\Sidechain$ are secure, but only
concern ourselves with \emph{direct observation} transactions, or transactions
that can be verified without relying on sidechain certificates.
We show that such
transactions will always be correctly verified
in this case.
%as long as Persistence of both $\Mainchain$
%and $\Sidechain$ are satisfied.

Next, we establish that, when only $\Mainchain$ is secure, it is impossible for the
$\Mainchain$ maintainers to accept a view inconsistent with the validity language, and
hence the firewall property is maintained in the case of a sidechain failure.
%When $\Mainchain$ has persistence, this holds for the shared view across \emph{all}
%parties which is derived in Lemma~\ref{lem:catastrophe-firewall}.

Finally, the heart of the proof is a computational reduction (using the above
partial results) showing how, given
an adversary that breaks the firewall property,
%when both $\Mainchain$ and $\Sidechain$ are secure,
there must exist a receiving transaction on $\Mainchain$
which breaks the validity of the scheme. Given such a transaction, we can
construct an adversary against either the security of the underlying ATMS scheme or the
collision resistance of the underlying hash function.
%Under the
%assumption that both the ATMS scheme is secure and the hash function
%collision-resistant, the security of the sidechains protocol follows.

\subsubsection{Liveness and Persistence}

We begin by stating the persistence and liveness guarantees of our
construction, they both follow directly from the guarantees shown for the
standalone Ouroboros blockchain in~\cite{ouroboros}.

\begin{lemma}[Persistence and Liveness]\label{lem:perslive}
  Consider the construction of Section~\ref{sec:construction} with
  the assumptions $\Assum_\Sidechain, \Assum_\Mainchain$. For all slots $t$, if
  $\Assum_\Sidechain[t]$ (resp. $\Assum_\Mainchain[t]$) holds, then $\Sidechain$ (resp. $\Mainchain$)
  satisfies persistence and liveness up to slot $t$ with overwhelming probability in $k$.
\end{lemma}

We now restate the Common Prefix property of blockchains for future reference.
If the Common Prefix property holds, then Persistence can be derived along the
lines of~\cite{ouroboros}.

\begin{definition}[Common Prefix]
  For every honest party $\party_1$ and $\party_2$
  both maintaining the same ledger (i.e., either both maintaining $\Mainchain$, or both
  maintaining $\Sidechain$) and for every slot $r_1$ and $r_2$ such that
  $r_1 \leq r_2 \leq t$, let $\chain_1$ be the adopted chain of $\party_1$ at
  slot $r_1$ and $\chain_2$ be the adopted chain of $\party_2$ at slot $r_2$.
  The \emph{$k$-common prefix property} for slot $t$ states
  that $\chain_2[:|\chain_1[:-k]|] = \chain_1[:-k]$.
\end{definition}

\subsubsection{The Firewall Property and $\Mainchain$-Receiving Transactions}

Recall that the transactions in $\Trans_\ada$ can be partitioned into several classes with
different validity-checking procedures. First, there are
\emph{local} transactions (where $\send=\rec=\llid$)
and
\emph{sending} transactions (with $\llid=\send\neq\rec$).
Then we have
\emph{receiving} transactions (with $\send\neq\rec=\llid$),
which can be split into
\emph{$\Sidechain$-receiving} transactions ($\send\neq\rec=\llid=\Sidechain$)
and
\emph{$\Mainchain$-receiving} transactions ($\send\neq\rec=\llid=\Mainchain$).

As the lemma below observes, if a transaction violates the firewall property in
a certain situation, it must be an $\Mainchain$-receiving transaction.

%Before we turn our attention to proving that the firewall property holds for{{{
%cross-chain transactions, we first address the simpler case of transactions that
%can be locally verified or that can be verified with direct observation.

%The transactions $\tx$ that can be locally verified have the property that
%$\send(\tx) = \llid(\tx)$. Their validity only depends on previous transactions
%that have been included on the same ledger (assuming that those have already
%been evaluated as valid). Therefore, the law of conservation and the rest of the
%local rules can be directly validated. These transactions are either local
%transactions in which $\llid(\tx)=\send(\tx) = \rec(\tx)$ or the \emph{sending}
%part of a cross-chain transfer such that $\llid(\tx)=\send(\tx) \neq \rec(\tx)$.
%This result is \emph{unconditional} and holds even if there is a signature
%forgery, because the definition of Algorithm~\ref{alg.validity} only requires
%that the signature passes validation. If the underlying signature scheme allows
%forgeries, then transactions with forged signatures can be part of sequences
%which belong to $\adalang$ and therefore members of the validity language.

%The transactions that are verifiable via  direct observation are those that have
%$\send(\tx) \neq \llid(\tx)$, but $\llid(\tx) = \Sidechain$. Because the $\Sidechain$
%maintainers directly observe $\Mainchain$, these transactions can also be treated
%easily. The result here is conditioned on the persistence of $\Mainchain$.

%The following lemma captures both of these cases.

%\begin{definition}[Immediately verifiable transaction]
  %Let $\tx \in \Trans_\ada$. We call $\tx$ an \emph{immediately verifiable transaction}
  %if $\llid(\tx) = \send(\tx)$ or $\llid(\tx) = \Sidechain$.
%\end{definition}}}}

\begin{lemma}\label{lem:firewall-tx-types}
  Consider an execution of the protocol of Section~\ref{sec:construction} at
  slot $t$ in
  which $\Mainchain$ and $\Sidechain$ satisfy persistence.
  Suppose
  $$
    \LState =
    \merge\left(
        \{\LState_\Mainchain^{\cup}[t], \LState_\Sidechain^{\cup}[t]\}
    \right)
    \not\in
    \adalang
  %\; .
  $$
  and suppose that $\Secure_t = \{\Sidechain, \Mainchain\}$.
  Let $\LState'$ be the minimum prefix of $\LState$ such that
  $\LState' \not\in \adalang$. Then
  $\LState'\neq\eps$ and
  $\tx \defeq \LState'[-1]$
  is an $\Mainchain$-receiving transaction.
\end{lemma}

\begin{proof}
  The \emph{base} property of the validity language implies $\LState' \neq
  \eps$, hence $\tx$ exists. Due to the minimality of~$\LState'$,
  Algorithm~\ref{alg.validity} returns \emph{false} for $\LState'$ but
  \emph{true} for $\LState'[:-1]$. Since it processes transactions sequentially,
  it must return \emph{false} during the processing of $\tx$. Suppose for
  contradiction that $\tx$ is not an $\Mainchain$-receiving transaction; let us call
  such a transaction \emph{direct} in this proof.

  Algorithm~\ref{alg.validity} can output \emph{false} while processing a direct
  transaction in the following cases: (a) in
  Line~\ref{alg.validity.conservation-failure} when there is a Conservation Law
  violation; (b) in Line~\ref{alg.validity.sig-failure} when there is a
  signature validation failure; (c) in Line~\ref{alg.validity.replay-failure}
  when $\tx$ is a replay of a previous transaction; (d) in
  Line~\ref{alg.validity.prior-failure-1} when $\tx$ is a replay, or (e) in
  Line~\ref{alg.validity.prior-failure-2} when the pre-image transaction has not
  yet been processed. Hence, $\tx$ falls under one of these violations.

  Due to persistence and the definition of $\LState_{\Mainchain}^{\cup}[t]$ and
  $\LState_{\Sidechain}^{\cup}[t]$, there exists an $\Mainchain$ maintainer $\party_\Mainchain$ and
  an $\Sidechain$
  maintainer $\party_\Sidechain$, such that
  $\LState_{\Mainchain}^{\party_\Mainchain}[t] = \LState_{\Mainchain}^{\cup}[t]$
  and
  $\LState_{\Sidechain}^{\party_\Sidechain}[t] = \LState_{\Sidechain}^{\cup}[t]$,
  respectively.
  Due to the \emph{partitioning property} of $\merge$, $\tx$ will be in
  $\LState_{\llid(\tx)}^{\party_{\llid(\tx)}}[t]$.
  We separately consider the two possibilities for $\llid(\tx)$.

  \textbf{Case 1: } $\llid(\tx) = \Mainchain$.
  In this case, the only violations that a direct $\tx$ can attain
  are (a), (b) and (c), as the cases (d) and (e) for $\llid(\tx) = \Mainchain$ do not
  pertain to a direct transaction. $\party_\Mainchain$ has reported
  $\LState_\Mainchain^{\party_\Mainchain}[t]$ as its adopted state, hence
  $\LState_\Mainchain^{\party_\Mainchain}[t]$ is a fixpoint of $\textsc{verifytx}_\Mainchain$ (as
  $\textsc{verifytx}_\Mainchain$ checks for a fixpoint). The execution of
  $\textsc{verifytx}_\Mainchain$ included every transaction in
  $\LState_\Mainchain^{\party_\Mainchain}[t]$.
  Therefore, $\textsc{verifytx}_\Mainchain$ has accepted every transaction in every
  iteration until the last iteration, which processes $\tx$.
  Consider, now, what happened in the last iteration of the execution of
  $\textsc{verifytx}_\Mainchain$.
  In that iteration, $\textsc{verifytx}_\Mainchain$ checks the
  validity of~$\sigma$, the Conservation Law, and transaction replay. In
  all cases (a), (b) and (c), $\textsc{verifytx}_\Mainchain$ will reject $\tx$. But
  this could not have happened, as $\LState_\Mainchain^{\party_\Mainchain}[t]$ is a fixpoint,
  and we have a contradiction.

  \textbf{Case 2: } $\llid(\tx) = \Sidechain$.
  Let $\chainmc$ and $\chainsc$ be the $\Mainchain$ and respectively $\Sidechain$ chain
  adopted by $\party_\Sidechain$ at slot~$t$ (and recall that $\party_\Sidechain$ maintains
  both chains). Let $\chainmc'$ be the chain adopted by
  $\party_\Mainchain$ at slot $t$. As before,
  $\textsc{annotatetx}_\Sidechain(\chainmc,\chainsc)$ must be a fixpoint of
  $\textsc{verifytx}_\Sidechain$ (as $\textsc{verifytx}_\Sidechain$ checks for a fixpoint).
  As in the previous case, $\tx$ cannot violate (a), (b), (c) and in this case
  nor (d), as this would constitute a fixpoint violation. Hence $\tx$ is an
  effect transaction and we will examine whether $\tx$ constitutes a violation
  of~(e).

  Let $\tx^{-1} \defeq \eff{\Mainchain}{\Sidechain}^{-1}(\tx)$. Since $\tx$ is accepted
  by $\textsc{verifytx}_\Sidechain$ on input
  $\textsc{annotatetx}_\Sidechain(\chainmc,\chainsc)$, we deduce that
  there exists some block $B \in \chainmc[:-k]$
  with $\tx^{-1} \in B$. But $\chainmc'[:-k]$
  is the longest stable chain among
  $\Mainchain$ maintainers (due to $\LState_\Mainchain^\cup[t] = \LState_\Mainchain^{\party_\Mainchain}[t]$),
  hence $\chainmc[:-k]$ is its prefix. Therefore
  $B \in \chainmc'[:-k]$.
  Hence, $\tx^{-1} \in \Ledger^{\party_\Mainchain}_\Mainchain[t]$.
  Due to the \emph{partioning property} of $\merge$, $\tx^{-1}$ must appear in
  the output of $\merge\left(
      \{\LState_\Mainchain^{\party_\Mainchain}[t], \LState_\Sidechain^{\party_\Sidechain}[t]\}
  \right)$.
  Due to the
  \emph{topological soundness} of $\merge$, $\tx^{-1}$ must appear
  \emph{before} $\tx$
  in
  $\merge\left(
      \{\LState_\Mainchain^{\party_\Mainchain}[t], \LState_\Sidechain^{\party_\Sidechain}[t]\}
  \right)$. Hence, it cannot be the case that (e) is violated, as the pre-image
  transaction exists.
\end{proof}

\subsubsection{Firewall Property During Sidechain Failure}

%Now that we have studied what happens to direct observation transactions when
%both chains are secure, i.e., at slots $t$ such that $\Secure_t = \{\Mainchain, \Sidechain\}$,

We now turn our attention to the case where the sidechain has suffered a
``catastrophic failure'' and so $\Secure_t = \{\Mainchain\}$. We describe why a
catastrophic failure in the sidechain does not violate the firewall property. To
do this, we need to illustrate that, given a transaction sequence $\LState$ which is
accepted by the $\Mainchain$ verifier, we can ``fill in the gaps'' with transactions
from $\Sidechain$ in order to produce a new transaction sequence $\vec\tx$ which is
valid with respect to $\adalang$.

We prove this constructively in Lemma~\ref{lem:plausibility}. The construction
of such a sequence
is described in Algorithm~\ref{alg.plausibility}. The algorithm accepts a
transaction sequence $\LState \subseteq \Trans_\Mainchain$
valid according to
$\textsc{verifier}_\Mainchain$ and produces a transaction sequence $\vec\tx \in
\ValLang_\ada$ satisfying
$\proj_\Mainchain(\vec\tx) = \LState$, as desired.

The algorithm works by mapping each $\tx \in \LState$ to one or more transactions in
$\vec\tx$. The mapping is done by calling $\textsf{plausibility-map}(\tx)$ for
each transaction individually. Hence each transaction in $\vec\tx$ has a
specific preimage transaction in $\LState$, which can be shared by other transactions
in $\vec\tx$. The mapping is performed as follows. If $\tx$ is a local
transaction, then it is simply copied over, otherwise
some extra transactions are included. Specifically, if it's an
sending transaction $\tx$, then first $\tx$ is included, and
subsequently the funds are recovered by a corresponding transaction $\tx_1$ on
$\Sidechain$, the effect transaction of $\tx$. The funds are afterwards moved to a
pool address $\textsf{pool}_{pk}$ by a transaction $\tx_2$.
(Note that for this, we assume that the receiving account public key has a
correspnding private key, as this key is needed to sign $\tx_2$. As we are only
demonstrating the existence of $\vec\tx$, Algorithm~\ref{alg.plausibility} does
not need to be efficient and so assuming the existence of the private key is
sufficient.)
On the other hand,
if it is an ($\Mainchain$-)receiving transaction $\tx$, the reverse procedure is
followed. First, the funds are collected by $\tx_2$ from the pool address
$\textsf{pool}_{pk}$ and moved into the $\Sidechain$ address which will be used for the
upcoming remote transaction. Then $\tx_1$ moves the funds out of $\Sidechain$ so that
they can be collected by the corresponding $\tx$ on $\Mainchain$. In the first case, the
transaction sequence is $(\tx, \tx_1, \tx_2)$ and in the second case the
sequence is $(\tx_2, \tx_1, \tx)$. Note that, in both cases, $\tx$ and $\tx_1$
are identical, except for the fact that $\tx$ is recorded on $\Mainchain$ while $\tx_1$
is recorded on $\Sidechain$; the latter is the effect (or pre-image, respectively)
of the former.

The simple intuition behind this construction is that, in the plausible history
$\vec\tx$ produced by Algorithm~\ref{alg.plausibility}, the account $\textsf{pool}_{pk}$
is holding all the money of the sidechain. More specifically, the
balance that is maintained in the variable
$\textsf{balances}[\Sidechain][\textsf{pool}_{pk}]$ is identical to the $\textsf{pool}$
variable maintained by the $\Mainchain$ verifier. This invariant is made formal in
Lemma~\ref{lem:plausible-balances}.

\begin{lemma}[Plausible balances]\label{lem:plausible-balances}
  Let $\LState \in \Trans_{\ada,\Mainchain}^*$ and $\vec\tx \gets \textsf{plausible}(\LState)$.
  Consider an execution of
  Algorithm~\ref{alg.validity} on $\vec\tx$ and an execution of
  $\textsc{verifier}_{\Mainchain}$ on $\LState$. Let $\tx \in \LState$. Call
  $\textsf{pool}_{\tx}$ the value of the \textsf{pool} variable maintained by
  $\textsc{verifier}_{\Mainchain}$ prior to processing $\tx$ in its
  main \emph{for} loop; call
  $\textsf{balances}[\Sidechain][\textsf{pool}_{pk}]_{\tx}$ the value of the
  $\textsf{balances}[\Sidechain][\textsf{pool}_{pk}]$ variable prior to the iteration
  of its main \emph{for} loop which processes the first item of
  $\textsf{plausibility-map}(\tx)$. For all $\tx \in \LState$, the following
  invariant will hold: $\textsf{pool}_{\tx} =
  \textsf{balances}[\Sidechain][\textsf{pool}_{pk}]_{\tx}$.
\end{lemma}

\begin{proof}
  By direct inspection of the two algorithms, observe that
  $\textsf{balances}[\Sidechain][\textsf{pool}_{pk}]$ are updated by
  Algorithm~\ref{alg.validity} only when $\send(\tx_a) \neq \rec(\tx_a)$. The
  balances are increased when $\send(\tx_a) = \Mainchain$ (due to $\tx_2 \in
  \textsf{plausibility-map}(\tx)$ at Line~\ref{alg.plausibility.mc-sc-sc} of
  Algorithm~\ref{alg.plausibility}) and decreased when $\send(\tx_a) = \Sidechain$ (due
  to $\tx_2 \in \textsf{plausibility-map}(\tx)$ at
  Line~\ref{alg.plausibility.sc-sc-sc} of Algorithm~\ref{alg.plausibility}).
  Exactly the same accounting is performed by $\textsc{verifier}_{\Mainchain}$ when the
  respective $\tx$ is processed.
\end{proof}

\import{chapters/sidechains/}{algorithms/alg.plausibility.tex}

We now prove the correctness of Algorithm~\ref{alg.plausibility} in
Lemma~\ref{lem:plausibility}.

\begin{lemma}[Plausibility]\label{lem:plausibility}
  For all $\LState \in \Trans_{\ada,\Mainchain}^*$, if $\textsc{verifytx}_\Mainchain(\LState) =
  \LState$ then $\vec\tx \gets \textsf{plausible}(\LState)$ will satisfy $\vec\tx \in
  \adalang$.
\end{lemma}
\begin{proof}
  Suppose for contradiction that $\vec\tx \not\in
  \adalang$ and let $\vec\tx'$ be the minimum prefix of $\vec\tx$ such
  that $\vec\tx' \not \in \ValLang_{\ada}$. From the validity language
  \emph{base} property we have that $\vec\tx' \neq \eps$ and so it must have at
  least one element. Let $\tx \defeq \vec\tx'[-1]$ and let $\tx_{\LState} \in \LState$ be the input
  to \textsf{plausibility-map} which caused $\tx$ to be included in $\vec\tx$ in
  the execution of \textsf{plausible} in Algorithm~\ref{alg.plausibility}.
  Since Algorithm~\ref{alg.validity} processes transactions sequentially, and
  by the minimality of $\vec\tx'$, it must return \emph{false} when $\tx$ is
  processed.

  We distinguish the following cases for $\tx_{\LState}$:

  \textbf{Case 1: Local transaction:} $\send(\tx_{\LState}) = \rec(\tx_{\LState})$.
  Then $\tx = \tx_{\LState}$ and $\send(\tx) = \llid(\tx)$. Since
  $\LState$ is a fixpoint of $\textsc{verifytx}_\Mainchain$,
  $\tx$ must (a) have a valid signature $\sigma$, (b) not be a replay transaction,
  and (c) respect the Conservation Law. As $\tx_{\LState}$ is a local
  transaction satisfying all of (a), (b) and (c), therefore
  $\vec\tx' \in \adalang$, which is a contradiction.

  \textbf{Case 2: Sending transaction:} $\send(\tx_{\LState}) = \Mainchain$ and $\rec(\tx_{\LState}) =
  \Sidechain$. In this case, let $(\tx_{\LState}, \tx_1, \tx_2) = \textsf{plausibility-map}(\tx_{\LState})$.
  If $\tx = \tx_{\LState}$,
  then $\tx$ is a sending transaction
  and we can apply the same
  reasoning to argue that it will respect properties (a), (b) and (c). But those
  are the only violations for which Algorithm~\ref{alg.validity} can reject an
  sending transaction, and hence $\vec\tx' \in \adalang$, which is a
  contradiction.

  If $\tx = \tx_1$, then Algorithm~\ref{alg.validity} must return \emph{true}.
  To see this, consider the cases when Algorithm~\ref{alg.validity} returns
  \emph{false}: (d) a replay failure in Line~\ref{alg.validity.prior-failure-1},
  which cannot occur as $\tx_{\LState}$ has been accepted by $\textsc{verifytx}_\Mainchain$ and
  so $\textsc{verifytx}_\Mainchain$ must have \emph{seen} $\tx_{\LState}$ only once while
  Algorithm~\ref{alg.validity} must be seeing it for exactly the second time; or
  (e) a mismatch failure in Line~\ref{alg.validity.prior-failure-1} which cannot
  occur as $\tx_1$ is constructed identical to $\tx_{\LState}$.

  If $\tx = \tx_2$ then $\send(\tx) = \rec(\tx)$. This transaction cannot cause
  Algorithm~\ref{alg.validity} to return \emph{false}. To see this, consider the
  cases when Algorithm~\ref{alg.validity} returns \emph{false}: (a) a signature
  failure in Line~\ref{alg.validity.sig-failure} cannot occur because $\sigma_2$
  was constructed correctly and the signature scheme is correct; (b) a replay
  failure in Line~\ref{alg.validity.replay-failure} cannot occur because
  $\txid_2$ is fresh; (c) a conservation failure in
  Line~\ref{alg.validity.conservation-failure} cannot occur because the
  immediately preceding transaction $\vec\tx'[-2]$ supplies sufficient balance.

  \textbf{Case 3: Receiving transaction:} $\send(\tx_{\LState}) = \Sidechain$ and
  $\rec(\tx_{\LState}) = \Mainchain$. In this case, let
  $(\tx_2, \tx_1, \tx_{\LState}) = \textsf{plausibility-map}(\tx_{\LState})$.
  The argument for $\tx = \tx_{\LState}$ and $\tx = \tx_1$ is as in \emph{Case 2}. For
  the case of $\tx = \tx_2$, the same argument as before holds for a signature
  validity and for replay protection. It suffices to show that the conservation
  law is not violated. This is established in Lemma~\ref{lem:plausible-balances}
  by the invariant that $\textsf{pool}_{\tx_{\LState}} =
  \textsf{balances}[\Sidechain][\textsf{pool}_{pk}]_{\tx_{\LState}}$ that holds prior to
  processing $\tx_2$, as it is the first transaction of a triplet produced by
  \textsf{plausibility-map}. As $\textsc{verifytx}_{\Mainchain}(\LState) =
  \LState$ then therefore $\textsf{pool}_{\tx_{\LState}} - \amount \geq 0$
  and so $\textsf{balances}[\Sidechain][\textsf{pool}_{pk}]_{\tx_{\LState}} - amount \geq 0$
  and Algorithm~\ref{alg.validity} returns \emph{true}.

  All three cases result in a contradiction, concluding the proof.
\end{proof}

\begin{lemma}[$\Sidechain$ failure firewall]\label{lem:catastrophe-firewall}
  Consider any execution of the construction of Section~\ref{sec:construction}
  in which persistence holds for $\Mainchain$.
  For all slots $t$ such that $\Secure_t = \{\Mainchain\}$
  we have that
  $$
    \merge(\{\Ledger_\Mainchain^\cup[t]\})
    \in
    \proj_{\{\Mainchain\}}(\ValLang_{\ada})
  \; .
  $$
\end{lemma}

\begin{proof}
  From the assumption that persistence holds, there exists some $\Mainchain$ party
  $\party$
  for which $\Ledger_\Mainchain^\party[t] = \Ledger_\Mainchain^{\cup}[t]$.
  Additionally, $\merge(\{\Ledger_\Mainchain^{\cup}[t]\}) = \Ledger_\Mainchain^{\cup}[t]$ due to the
  \emph{partitioning} property.
  It suffices to show that there exists some $\vec\tx \in \adalang$ such
  that $\proj_{\{\Mainchain\}}(\vec\tx) = \Ledger_\Mainchain^{\party}[t]$. Let
  $\vec\tx \gets \textsf{plausible}(\Ledger_\Mainchain^{\party}[t])$. We have
  $\textsc{verifier}_\Mainchain(\Ledger_\Mainchain^{\party}[t]) = \text{\emph{true}}$, so apply
  Lemma~\ref{lem:plausibility} to obtain that $\vec\tx \in \adalang$.

  To see that $\proj_{\{\Mainchain\}}(\vec\tx) = \Ledger_\Mainchain^{\party}[t]$, note that
  Algorithm~\ref{alg.plausibility} for input $\LState$ includes all $\tx \in \LState$ in the
  same order as in its input. Furthermore, all $\tx \in \vec\tx$ such that $\tx
  \not\in \LState$ have $\llid(\tx) = \Sidechain$ and so are excluded from the projection.
\end{proof}

\subsubsection{General Firewall Property}

In preparation for establishing the full firewall property, we state the
following simple technical lemma.
%we remark that at least $k + 1$ slots of $2k$
%slots must be honest. This lemma will be used to argue that, in an honest
%execution in which an ATMS key is created by combining $2k$ keys, a
%$k$-threshold suffices to ensure only honestly approved messages can be signed.

\begin{lemma}[Honest subsequence]\label{lem:honest-subsequence}
  Consider any set $S$ of $2k$ consecutive slots prior to slot $t$ in an
  execution of an Ouroboros ledger $\Ledger$ such that %, prior to $t$,
  $\Assum_{\hm}(\Ledger)[t]$ holds. Then $k + 1$ slots of $S$ are honest, except
  with negligible probability.
\end{lemma}
\begin{proof}[Sketch]
  If the adversary controlled at least $k$ out of any $2k$ consecutive slots, he
  could use them to produce an alternative $k$-blocks long chain for this
  interval without any help from the honest parties, resulting in a violation of
  common prefix and hence persistence (cf. Lemma~\ref{lem:perslive}).
  %Suppose $k$ slots of $S$ are adversarial. Then the adversary can cause a
  %Common Prefix violation. Suppose that during the first slot of $S$ some honest
  %party $\party$ has adopted block $B_1$. The adversary waits, without
  %generating any blocks, for the honest parties to generate their chain until
  %the last slot of $S$, and suppose that party $\party$ has now adopted some
  %block $B_2$ and note that $B_2$ is $k$ blocks in front of $B_1$. Subsequently,
  %the adversary ignores all the honestly generated blocks between $B_1$ and
  %$B_2$ and extends the blockchain whose tip is $B_1$ with $k$ blocks, arriving
  %at block $B_2'$. This is a $k$-common prefix violation, which contradicts
  %Persistence.
\end{proof}

We are now ready to prove our key lemma, showing that our
construction satisfies the firewall property.

\begin{lemma}[Firewall]\label{lem:firewall}
  For all PPT adversaries $\mathcal{A}$, the construction of
  Section~\ref{sec:construction} with a secure ATMS and a collision-resistant
  hash function satisfies the firewall property with respect to assumptions
  $\Assum_\Mainchain, \Assum_\Sidechain$ with overwhelming probability in $k$.
\end{lemma}
\begin{proof}
  Let $\mathcal{A}$ be an arbitrary PPT adversary against the firewall property,
  and $\mathcal{Z}$ be
  an arbitrary environment for the execution of $\mathcal{A}$.
  % PG: appears unused
  % and let $\lambda$ be the security parameter.
  We will construct the following PPT adversaries:
  \begin{enumerate}
    \item $\mathcal{A}_1$ is an adversary against ATMS.
    \item $\mathcal{A}_2$ is a collision adversary against the hash function.
  \end{enumerate}
  We first describe the construction of these adversaries.

  \bigskip
  \textbf{The adversary $\mathcal{A}_1$.}
  $\mathcal{A}_1$ simulates the execution of $\mathcal{A}$ and $\env$ and
  of two populations of maintainers for two blockchains, $\Mainchain$ and $\Sidechain$,
  which run the protocol $\Pi$ (either the $\Mainchain$ or the $\Sidechain$-maintainer part
  respectively) and spawns parties according to the mandates of the environment
  $\mathcal{Z}$ as follows. For all parties that are spawned as $\Mainchain$
  maintainers, $\mathcal{A}_1$ generates keys internally by invoking the $\Gen$
  algorithm of the ATMS scheme. For all parties that are spawned as $\Sidechain$
  maintainers, $\mathcal{A}_1$ uses the oracle $\mathcal{O}^\textsf{gen}$
  to produce the public keys $vk_i$.

  Whenever $\mathcal{A}$ requests that a (block or transaction) signature in
  $\Sidechain$  is created, $\mathcal{A}_1$ invokes its oracle
  $\mathcal{O}^\textsf{sig}$ to obtain the respective signature to provide to
  $\mathcal{A}$. When $\mathcal{A}$ requests that a $\Mainchain$ signature is created,
  $\mathcal{A}_1$ uses its own generated private key to sign by invoking the
  $\Sig$ algorithm of the ATMS scheme. If $\mathcal{A}$ requests the corruption
  of a certain party $\party^*$, then $\mathcal{A}_1$ reveals $\party^*$'s
  private key to $\mathcal{A}$ as follows: If $\party^*$ is a $\Mainchain$ maintainer,
  then the secret key is directly available to $\mathcal{A}_1$, so it is
  immediately returned. Otherwise, if $\party^*$ is a $\Sidechain$ maintainer, then
  $\mathcal{A}_1$ obtains the secret key of $\party^*$ by invoking the oracle
  $\mathcal{O}^\textsf{cor}$.

  For every time slot $t$ of the execution, $\mathcal{A}_1$ inspects all pairs
  $(\party_\Mainchain, \party_\Sidechain)$ of honest parties such that $\party_\Mainchain$ is a $\Mainchain$
  maintainer and $\party_\Sidechain$ is a $\Sidechain$ maintainer such that
  $\LState_\Mainchain^{\party_\Mainchain}[t] = \LState_\Mainchain^\cup[t]$ and
  $\LState_\Sidechain^{\party_\Sidechain}[t] = \LState_\Sidechain^\cup[t]$ (if such parties exist).
  Let $\LState_1 = \LState_\Mainchain^{\party_\Mainchain}[t]$ and
  $\LState_2 = \LState_\Sidechain^{\party_\Sidechain}[t]$.
  The adversary obtains the stable portion of the
  honestly adopted chain, namely $\chain_1 = \LView{\chain}{\party_\Mainchain}{t}[:-k]$ and the
  transactions included in $\chain_1$, namely $\LState'_1$ (note that
  $\LState'_1 \neq \LState_1$ if $\LState'_1$ contains certificate
  transactions). $\mathcal{A}_1$ examines whether $\LState = \merge(\LState_1,
  \LState_2) \not\in\adalang$, to deduce whether $\mathcal{A}$ has succeeded.
  Note that both the evaluation of $\merge$ on arbitrary states and the
  verification of inclusion in $\adalang$ are efficiently computable and hence
  $\mathcal{A}_1$ can execute them. If $\mathcal{A}_1$ is not able to find such
  a time slot $t$ and parties $\party_\Mainchain, \party_\Sidechain$, it returns \textsc{failure}
  (in the latter part of this proof, we will argue that all $\mathcal{A}_1$
  failures occur with negligible probability conditioned on the event that
  $\mathcal{A}$ is successful, unless $\mathcal{A}_2$ is successful).

  Otherwise it obtains the minimum $t$ for which this holds and the $\LState$
  for this $t$. Because of the \emph{base property} of the validity language, we
  have that $\epsilon \in \adalang$ and therefore $\LState \neq \epsilon$. Let
  $\LState^*$ be the minimum prefix of $\LState$ such that $\LState^* \not\in
  \adalang$ and let $\tx = \LState^*[-1]$. If $\tx$ has $\send(\tx) \neq \Sidechain$ or
  $\llid(\tx) \neq \Mainchain$, then $\mathcal{A}_1$ returns \textsc{failure}. Now
  therefore $\send(\tx) = \Sidechain$ and $\llid(\tx) = \Mainchain$ (and so $\tx \in \LState_1$).
  Hence, $\tx$ references a certain certificate transaction, say $\tx'$. Due to
  the algorithm executed by $\Mainchain$ maintainers for validation, we will have that
  $\tx' \in \LState'_1\{:\tx\}$.

  Let $\vec\tx^*$ be the subsequence of $\LState'_1$ containing all certificate
  transactions up to and including $\tx'$. We will argue that there must exist
  some ATMS forgery among one of the certificate transactions in $\vec\tx^*$.
  $\mathcal{A}_1$ looks at every transaction $\sccert_j\in\vec\tx^*$ (and note
  that it will correspond to a unique epoch $\epoch_j$). $\sccert_j$ contains a
  message $m = (j,\langle\pending_j\rangle, avk^j)$ and a signature $\sigma_j$.
  $\mathcal{A}_1$ extracts the epoch $\epoch_j$ in
  which $\sccert_j$ was confirmed in $\chain_1$ (and note that we must have $j >
  0$). $\mathcal{A}_1$ collects the public keys elected for the last $2k$ slots
  of epoch $\epoch_{j-1}$ according to the view of $\party_\Sidechain$
  into a set $\keyseq_{j-1}$ and similarly for $\keyseq_j$. $\mathcal{A}_1$
  collects the pending cross-chain transactions of $\epoch_{j-1}$ according to
  the view of $\party_\Sidechain$ into $\pending'_j$, and creates the respective
  Merkle-tree commitment $\commit{\pending'_j}$.
  $\mathcal{A}_1$
  checks whether the following \emph{certificate violation} condition holds:
  \begin{equation}
    \label{eq:cert-violation}
    \begin{gathered}
      \VerCombined(m, avk^{j-1}, \sigma_j) \text{ and}\\
      \Comprises(\keyseq_{j-1}, avk^{j-1}) \text{ and}\\
      \left(
        \lnot \Comprises(\keyseq_j, avk^j)
        \lor
        \langle\pending_j\rangle \neq \langle\pending'_j\rangle
      \right)
    \end{gathered}
  \end{equation}
  where $avk^{j-1}$ is extracted from $\sccert_{j-1}$ according to the view of
  $\party_\Sidechain$, unless $j = 1$ in which case $avk^0$ is known.
  If the condition~(\ref{eq:cert-violation}) holds for no $j$ then
  $\mathcal{A}_1$ returns \textsc{failure}, otherwise it denotes by $j^*$ the
  minimum $j$ for which~(\ref{eq:cert-violation}) holds and outputs the tuple
  %$\mathcal{A}_1$ extracts $(m, \sigma_j, avk^{j-1}, \keyseq^{j-1})$ from the first
  %certificate transaction that satisfies~(\ref{eq:cert-violation}) and returns the tuple
  $(m, \sigma_{j^*}, avk^{j^*-1}, \keyseq^{j^*-1})$.
  %If it fails to find such a $\sccert_j$, it returns \textsc{failure}.

  \bigskip
  \textbf{The adversary $\mathcal{A}_2$.}
  Like $\mathcal{A}_1$, $\mathcal{A}_2$ simulates the execution of
  $\mathcal{A}$ including two populations of maintainers and spawns parties
  according to the mandates of the environment $\mathcal{Z}$. For \emph{all}
  these parties, $\mathcal{A}_2$ generates keys internally. When $\mathcal{A}$
  requests that a transaction is created, $\mathcal{A}_2$ provides the signature
  with its respective private key. If $\mathcal{A}$ requests the corruption of a
  certain party, say $\party^*$, then $\mathcal{A}_2$ provides the respective
  private key to $\mathcal{A}$.

  For every time slot $t$ of the execution, $\mathcal{A}_2$ inspects all pairs
  of honest parties such that $\party_\Mainchain$ is a $\Mainchain$ maintainer and $\party_\Sidechain$ is
  a $\Sidechain$ maintainer such that
  $\LState_\Mainchain^{\party_\Mainchain}[t] = \LState_\Mainchain^\cup[t]$ and
  $\LState_\Sidechain^{\party_\Sidechain}[t] = \LState_\Sidechain^\cup[t]$
  and obtains the variables $\LState_1, \LState_2, \chain_1,
  \LState'_1$ as before. $\mathcal{A}_2$ examines whether $\LState =
  \merge(\LState_1, \LState_2) \not\in\adalang$, to deduce whether $\mathcal{A}$
  has succeeded. If $\mathcal{A}_2$ is not able to find such a time slot $t$ and
  parties $\party_\Mainchain, \party_\Sidechain$, it returns \textsc{failure}. Let $\tx$ be as in
  $\mathcal{A}_1$. If $\send(\tx) \neq \Sidechain$ or $\llid(\tx) \neq \Mainchain$, then
  $\mathcal{A}_2$ returns \textsc{failure}. Then $\tx$ references a certain
  certificate transaction $\sccert_j = (j,\langle\pending_j\rangle, avk^j,\sigma_j)$ and
  uses a Merkle tree proof $\pi$ which proves the inclusion of $\tx$ in
  $\pending_j$. If $\sccert_j \not\in \LState'_1$,
  then $\mathcal{A}_2$ returns
  \textsc{failure}. When $\sccert_j$ was accepted by $\party_\Sidechain$, $\pending_j$
  included a set of transactions $\vec\tx$ in the view of $\party_\Sidechain$. If $\tx
  \in \vec\tx$, then $\mathcal{A}_2$ returns \textsc{failure}. Otherwise, the
  Merkle tree $\langle\pending_j\rangle$ was constructed from $\vec\tx$, but a
  proof-of-inclusion $\pi$ for $\tx \not\in \vec\tx$ was created. From this
  proof, $\mathcal{A}_2$ extracts a hash collision and returns it.

  \bigskip
  \textbf{Probability analysis.}
  Define the following events:
  \begin{itemize}
    \item $\scforge[t]$: $\mathcal{A}$ is successful at slot $t$, i.e.,
          $\proj_{\ada}\left(\merge(\{\LState_i^{\cup}[t]: i \in \Secure_t\})\right) \not\in
          \proj_{\Secure_t}(\adalang)$.
    \item \textsc{atms-forge}:  $\mathcal{A}_1$ finds an
          index $j^*$ for which the condition~(\ref{eq:cert-violation}) occurs.
          %  both
          %$\VerCombined(m, avk^{j-1}, \sigma_j)$
          %and
          %$\Comprises(\keyseq_{j-1}, avk^{j-1})$
          %are satisfied, but
          %$\lnot \Comprises(\keyseq_j, avk^j)$ or
          %$\langle\pending_j\rangle \neq \langle\pending'_j\rangle$.
    \item \textsc{hash-collision}:  $\mathcal{A}_2$ finds a
          hash function collision.
    %\item $\textsc{mc-violation}[t]$: $\Mainchain \not \in \Secure_t$.
    %\item $\textsc{sc-violation}[t]$: $\Sidechain \not \in \Secure_t$.
  \end{itemize}
  Note that ledger states in the protocol only contain $\ada$-transactions,
  hence
  $\proj_\ada$ is the identity function and
  $\textsc{sc-forge}[t]$ is equivalent to
  $
  \merge\left(
    \setd
      {\Ledger_i^{\cup}[t]}
      {i\in\Secure_t}
  \right)
  \not\in
  \proj_{\Secure_t}(\adalang)
  %\; .
  $.
  We will now show that for every~$t$, the probability $\Pr[\textsc{sc-forge}[t]]$ is
  negligible.
  We distinguish two cases:

  \textbf{Case 1:}
  %$\lnot\textsc{mc-violation}[t]$ and $\lnot\textsc{sc-violation}[t]$.
  $\Secure_t = \{\Mainchain,\Sidechain\}$.
  %We conclude that $\Secure_t = \{\Mainchain, \Sidechain\}$ and that
  In this case Persistence holds for both $\Mainchain$ and $\Sidechain$,
  and $\proj_{\Secure_t}$ is the identity function.
  We deal with this case in two successive claims (both implicitly conditioning
  on being in Case~1).
  First we show that, if $\textsc{sc-forge}[t]$ occurs, then one of
  \textsc{atms-forge}, \textsc{hash-collision} occurs.
  Therefore applying a union bound, we will have that:
  \begin{equation*}
    \label{ineq}
  \Pr[\textsc{sc-forge}[t]] \leq \Pr[\textsc{atms-forge}] + \Pr[\textsc{hash-collision}]
  \; .
  \end{equation*}
  Second, we show that $\Pr[\atmsforge]$ is
  negligible (and the negligibility of $\Pr[\hcol]$ follows from our assumption
  that the hash function is collision resistant).

  \textbf{Claim 1a:}
  $\textsc{sc-forge}[t] \Rightarrow \textsc{atms-forge} \lor \textsc{hash-collision}$.

  \noindent
  Because persistence holds in both $\Mainchain$ and $\Sidechain$, we know that there exist two parties $\party_\Mainchain, \party_\Sidechain$
  such that at slot $t$ we have that $\Ledger_\Mainchain^{\party_\Mainchain}[t] =
  \Ledger_\Mainchain^{\cup}[t]$ and $\Ledger_\Sidechain^{\party_\Sidechain}[t] =
  \Ledger_\Sidechain^{\cup}[t]$,
  respectively. Therefore $\scforge[t]$ implies
  $$
    \merge(\{
      \Ledger_\Mainchain^{\party_\Mainchain}[t],
      \Ledger_\Sidechain^{\party_\Sidechain}[t]
    \}) \not\in \adalang
  \; .
  $$
  Let $\tx, \tx'$ be as in the definition of
  $\mathcal{A}_1$.
  By Lemma~\ref{lem:firewall-tx-types} and using $\Mainchain$ and $\Sidechain$
  persistence, $\tx$ will exist and
  be an $\Mainchain$-receiving transaction.
  Hence, $\send(\tx) = \Sidechain$ and $\rec(\tx) = \llid(\tx) = \Mainchain$.
  Therefore, $\tx'$ will also exist.
  %We distinguish two cases, depending on whether
  If $\mathcal{A}_1$ finds the index $j^*$ for which~(\ref{eq:cert-violation})
  is satisfied,
  %there exists, for some $j$, a certificate $\sccert_j$ which satisfies the
  %\emph{certificate violation} condition~(\ref{eq:cert-violation}).
  %, or it will not.
  then \textsc{atms-forge} has occured and the claim is established, so let us assume otherwise.
  %Now consider the case where no such $\sccert_j$ exists.
  % PG: seems to repeat exactly what the previous sentence says.
  %Then no certificate satisfies the \emph{certificate violation} condition.
  Hence, for each certificate
  $\sccert_j$ containing a message $m = (j,\langle\pending_j\rangle, avk^j)$, it
  holds that
  \begin{equation}
    \label{eq:cert-good}
    \begin{gathered}
    \left(
      \VerCombined(m, avk^{j-1}, \sigma_j)
      \land
      \Comprises(\keyseq_{j-1}, avk^{j-1})
    \right)\\
    \Rightarrow\\
    \left(
      \Comprises(\keyseq_j, avk^j)
      \land
      \langle\pending_j\rangle = \langle\pending'_j\rangle
    \right)
    \; .
    \end{gathered}
  \end{equation}
  Therefore, we have a chain of certificates, each of which is signed with a
  valid key $avk^{j-1}$ and attests to the validity of the next key $avk^j$.
  For all of these certificates, $\VerCombined(m, avk^{j-1}, \sigma_j)$ holds,
  as it has been verified by $\party_\Mainchain$.
  Furthermore, by an induction argument (where the base case comes from the
  construction of $avk^0$ and the induction step follows
  from~(\ref{eq:cert-good})) we have
  $\Comprises(\keyseq_{j-1}, avk^{j-1})$ as well.

  As $\tx'$ is a certificate transaction which appears last in the above chain
  (with some index $\sccert_k$), the above implication also holds for $\tx'$,
  and so does its premise
  $
    \VerCombined(m, avk^{k-1}, \sigma_k)
    \land
    \Comprises(\keyseq_{k-1}, avk^{k-1})
  $.
  Therefore, the conclusion of the implication
  $\langle\pending_k\rangle = \langle\pending'_k\rangle$ holds.
  However, the sending transaction corresponding to $\tx$ has been proven to belong to the Merkle Tree
  $\langle\pending_k\rangle$ (as verified by $\party_\Mainchain$), but does not belong
  to $\pending'_k$ (by the selection of $\tx$). This constitutes a Merkle Tree collision,
  which translates to a hash collision. The construction of $\mathcal{A}_2$
  outputs exactly this collision, and in this case we deduce that
  $\mathcal{A}_2$ is successful and \textsc{hash-collision} follows.

  \textbf{Claim 1b:} $\Pr[\atmsforge]$  is negligible.

  \noindent
  Suppose that $\atmsforge$ occurs. We will argue that, in this case,
  $\mathcal{A}_1$ will have computed an ATMS forgery, which is a negligible
  event by the assumption that the used ATMS is secure.

  From the assumption that
  \textsc{atms-forge} has occurred, at epoch $\epoch_j$ we have that
  $\VerCombined(m, avk^{j-1}, \sigma_j)$ and $\Comprises(\keyseq_{j-1},
  avk^{j-1})$, but $\lnot \Comprises(\keyseq_j, avk^j)$ or
  $\langle\pending_j\rangle \neq \langle\pending'_j\rangle$. From
  Lemma~\ref{lem:honest-subsequence} and using $\Assum_{\hm}(\Sidechain)[t]$, we deduce that in the last $2k$ slots of epoch
  $\epoch_{j-1}$, at least $k+1$ must be honest. Since $\epoch_j$ is the
  earliest epoch in which this occurs, this means that $\keyseq_{j-1}$
  corresponds to the last $2k$ slot leaders of epoch $\epoch_{j-1}$, and all
  honest parties agree on the same $2k$ slot leaders. Hence, in the ATMS game,
  the number of keys in $\keyseq$ corrupted by the adversary through the use
  of the oracle $\mathcal{O}^\textsf{cor}(\cdot)$ is less than $k$. Furthermore,
  since $\lnot \Comprises(\keyseq_j, avk^j)$ or $\langle\pending_j\rangle \neq \langle\pending'_j\rangle$,
  the message $m$ contains either an invalid future aggregate key,
  an invalid Merkle Tree root of outgoing cross-chain transactions, or both.
  Hence, no honest party will sign the message $m$ for this epoch and therefore $|Q^\textsf{sig}[m]| = 0$. Hence
  $q < k$, %which constitutes an ATMS forgery.
  and $\adv_1$ wins the ATMS security game.

  \textbf{Case 2:}
  %$\textsc{mc-violation}[t]$ or $\textsc{sc-violation}[t]$
  %has occurred.
  $\Secure_t \neq \{\Mainchain,\Sidechain\}$.
  If $\Mainchain\not\in\Secure_t$ then, since
  $\Assum_\Mainchain[t] \Rightarrow \Assum_\Sidechain[t]$, we have $\Secure_t = \emptyset$ and
  $\lnot \textsc{sc-forge}[t]$, as $\epsilon \in \adalang$ by the
  \emph{base property}.
  %It remains to show that
  %$\textsc{sc-violation}[t] \rightarrow \lnot\textsc{sc-forge}[t]$ under the
  %condition that $\lnot \textsc{mc-violation}[t]$.
  %In that case,
  It remains to consider the case $\Secure_t = \{\Mainchain\}$. Using $\Mainchain$ persistence,
  by Lemma~\ref{lem:catastrophe-firewall} we obtain
  $\merge(\{\Ledger_\Mainchain^{\cup}[t]\}) \in \proj_{\{\Mainchain\}}(\adalang)$,
  %which is a contradiction.
  and hence $\scforge[t]$ did not occur.

  From the two above cases, we conclude that for every $t$,
  $\Pr[\textsc{sc-forge}[t]] \leq \textsf{negl}$. As the total number of slots is
  polynomial,
  we have shown that with overwhelming probability,
  we have that for all slots $t$ and for all
  $\Asset\in\bigcup_{i\in\Secure_t}\Assets(\Ledger_i)$,
  $
  \proj_{\Asset}\left(
    \merge\left(
      \setd
        {\Ledger_i^{\cup}[t]}
        {i\in\Secure_t}
    \right)
  \right)
  \in
  \proj_{\Secure_t}(\ValLang_\Asset)
  %\; .
  $, concluding the proof.
\end{proof}

  Lemmas~\ref{lem:perslive} and~\ref{lem:firewall} together directly imply the
  following theorem.

\begin{theorem}[Pegging Security]
  \label{thm:security}
  Consider the synchronous setting as defined in Section~\ref{sec:prelim-comm}
  with $2R$-semiadaptive corruptions as defined in
  Section~\ref{sec:prelim-corr}.  The construction of
  Section~\ref{sec:construction} using a secure ATMS and a collision resistant
  hash function is \textit{pegging secure} with liveness parameter
  $u=2k$
  with respect to
  assumptions $\Assum_\Mainchain$ and $\Assum_\Sidechain$ defined above,
  and $\merge$, $\effect$ and
  $\adalang$ defined in Section~\ref{sec:inst}.
\end{theorem}
