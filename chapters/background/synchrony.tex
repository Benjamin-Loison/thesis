\subsection{The Environment}

In our setting, we will study executions of protocols in which some parties
are \emph{honest} while others are \emph{adversarial}. All the honest parties
typically run the same code termed \emph{the honest protocol} (which is the
protocol we will design), while the adversary can run any code she wishes, but
is bounded by polynomial time bounds. Both the honest parties and the adversary
are probabilistic Turing Machines. As we are working in distributed settings,
our protocols will be long-lived and involve multiple parties running
simultaneously and communicating over the network while maintaining local state.
Among the parties in our execution, we will denote by $n$ the total number of
parties and with $t$ the number of parties that are adversarial. To strengthen
our adversary, we assume all the adversarial parties \emph{collude} and are
controlled by a single adversary. The situation where multiple adversaries are
not colluding is also captured by our stronger model (this can be captured by a
single adversary which simulates the multiple non-colluding adversaries).

To model the distributed setting, we must speak of executions concretely.
Towards this purpose, we conjure an \emph{environment} $\mathcal{Z}$ which is an
Interactive Turing Machine~\cite{interactive-tm} and is responsible for
orchestrating the whole execution. An Interactive Turing Machine is a Turing
Machine which models interactive computation by employing additional input and
output tapes that can be written to by external machines. The machine can decide
to pause computation by entering a special state and its computation is resumed
by writing to its input tape.

The environment spawns $n$ honest parties running the honest protocol $\Pi$ as
$n$ different Interactive Turing Machines. The environment also spawns one
adversarial Interactive Turing Machine $\mathcal{A}$. The honest parties and the
adversary can pass messages to the environment and receive messages from it by
writing and/or reading from their interactive tapes. The environment takes as
input the security parameter $1^\lambda$ and functions as an operating system
scheduler to activate the honest parties and the adversary according to some
schedule. The environment halts after polynomial time. The Interactive Turing
Machine model is equivalent to having the environment faithfully simulate the
execution of the honest parties and the adversary and correctly maintaining
their state across pausing and resumption.

We study an execution by observing its transcript (the messages exchanged by the
parties) as well as the internal state of the parties throughout the execution.
This transcript, which we will denote $\view_{\Pi,\mathcal{A}}^{n,t}$, is a
random variable which is a function of the coins of the probabilistic
Interactive Turing Machines that form the execution, namely the environment
itself, the adversary, the honest parties, and the Random Oracle. We remark that
this treatment is similar to the setting of Universal Composability~\cite{uc}.
Despite the similarities on the surface, we do not fully employ it and neither
are our protocols composable, nor are our security proofs simulation-based. On
the contrary, we use a direct property-based approach in our proofs instead of
employing universally composable functionalities.

\subsection{The Network}

\subsection{Synchrony and Adaptivity}
\todo{Expand this subsection}

\subsubsection{The Synchronous and Bounded Delay Setting}

We employ the model from~\cite{praos}, which is in turn based
on~\cite{ouroboros} and~\cite{backbone}.
The formalization we use below captures both synchronous and semi-syn\-chronous
communication; as well as both semi-adaptive and fully adaptive corruptions.

\subsubsection{Protocol Execution}
\label{sec:prelim-exec}

We divide time into discrete units called
\emph{slots}. %, as detailed later. % in Section~\ref{sec:comm}.
Players are equipped with (roughly) synchronized clocks that
indicate the current slot: we assume that any clock drift is subsumed in the
slot length.  Each slot $\slot_r$ is indexed by an integer $r \in \{1,2,\ldots
\}$.
We consider a UC-style~\cite{uc} execution of a protocol~$\Pi$,
involving an environment~$\env$, a number of
parties~$\party_i$, functionalities that these parties can access while running
the protocol (such as the $\DelDiff$ used for communication, described below), and
an adversary~$\adv$. All these entities are interactive algorithms.  The
environment controls the execution by activating parties via inputs it provides
to them. The parties, unless corrupted, respond to such activations by following
the protocol~$\Pi$ and invoking the available functionalities as needed.

\subsubsection{(Semi-)Adaptive Corruptions}
\label{sec:prelim-corr}

The adversary  influences the protocol execution by interacting
with the available functionalities, and by corrupting parties.
The adversary can only corrupt a party $\party_i$ if it is given
permission by the environment $\env$ running the protocol execution (captured as
a special message from $\env$ to $\adv$).
%The
%permission is in the form of a message $(\mathsf{Corrupt}, \party_i)$ which is
%provided to the adversary by the environment.
Upon receiving permission from the environment, the adversary
corrupts $\party_i$ after a certain delay of $\cordelay$ slots, where $\cordelay$ is
a parameter of our model. In particular, if $\cordelay=0$ we talk about
\emph{fully adaptive corruptions} and the corruption is immediate.
The model with $\cordelay>0$ is
referred to as allowing \emph{$\cordelay$-semi-adaptive corruptions} (as opposed to the
\emph{static corruptions model}, where parties can only be corrupted before the
start of the execution).
%
A corrupted
party $\party_i$ will relinquish its entire state to~$\adv$;
from this point on, the adversary will be activated in place of the
party $\party_i$.

\subsubsection{(Semi-)Synchronous Communication}
\label{sec:prelim-comm}

We employ the ``Delayed Diffuse'' functionality $\DelDiff_\Delta$ given in~\cite{praos} to
model (semi-)synchronous communication among the parties. It allows each party
to diffuse a message once per round, with the guarantee that it will be
delivered to all other parties in at most $\Delta$ slots (the delay within this
interval is under adversarial control). The adversary can also read and reorder
all messages that are in transit, as well as inject new messages.
We provide a detailed description of the functionality $\DelDiff_\Delta$ in
Appendix~\ref{app:diffuse} for completeness.

We refer to the setting where honest parties communicate via $\DelDiff_\Delta$
as the \emph{$\Delta$-semi-synchronous setting} and sometimes omit $\Delta$ if
it is clear from the context. The special case of $\Delta=0$ is referred to as
the \emph{synchronous setting}.
