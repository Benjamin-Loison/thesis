\subsection{The Environment}

In our setting, we will study executions of protocols in which some parties
are \emph{honest} while others are \emph{adversarial}. All the honest parties
typically run the same code termed \emph{the honest protocol} (which is the
protocol we will design), while the adversary can run any code she wishes, but
is bounded by polynomial time bounds. Both the honest parties and the adversary
are probabilistic Turing Machines. As we are working in distributed settings,
our protocols will be long-lived and involve multiple parties running
simultaneously and communicating over the network while maintaining local state.
Among the parties in our execution, we will denote by $n$ the total number of
parties and with $t$ the number of parties that are adversarial. To strengthen
our adversary, we assume all the adversarial parties \emph{collude} and are
controlled by a single adversary. The situation where multiple adversaries are
not colluding is also captured by our stronger model (this can be captured by a
single adversary which simulates the multiple non-colluding adversaries).

To model the distributed setting, we must speak of executions concretely.
Towards this purpose, we conjure an \emph{environment} $\mathcal{Z}$
\index{Environment} which is an
Interactive Turing Machine~\cite{interactive-tm} (ITMs) \index{Interactive
Turing Machine} and is responsible for
orchestrating the whole execution. An Interactive Turing Machine is a Turing
Machine which models interactive computation by employing additional input and
output tapes that can be written to by external machines. The machine can decide
to pause computation by entering a special state and its computation is resumed
by writing to its input tape.

The environment spawns $n - t$ honest parties running the honest protocol $\Pi$ as
$n$ different Interactive Turing Machines. The environment also spawns one
adversarial Interactive Turing Machine $\mathcal{A}$. The honest parties and the
adversary can pass messages to the environment and receive messages from it by
writing and/or reading from their interactive tapes. The environment takes as
input the security parameter $1^\lambda$ and functions as an operating system
scheduler to activate the honest parties and the adversary according to some
schedule. The environment halts after polynomial time. The Interactive Turing
Machine model is equivalent to having the environment faithfully simulate the
execution of the honest parties and the adversary and correctly maintaining
their state across pausing and resumption.

We study an execution by observing its transcript (the messages exchanged by the
parties) as well as the internal state of the parties throughout the execution.
This transcript, which we will denote $\view_{\Pi,\mathcal{A}}^{n,t}$, is a
random variable which is a function of the coins of the probabilistic
Interactive Turing Machines that form the execution, namely the environment
itself, the adversary, the honest parties, and the Random Oracle. We remark that
this treatment is similar to the setting of Universal Composability~\cite{uc}.
Despite the similarities on the surface, we do not fully employ it and neither
are our protocols composable, nor are our security proofs simulation-based. On
the contrary, we use a direct property-based approach in our proofs instead of
employing universally composable functionalities.

A skeleton for the environment is illustrated in Algorithm~\ref{alg.environment}.

\input{chapters/background/algorithms/alg.environment}

At the beginning of the execution, all the ITMs are booted by invoking their
\textsf{init} method. The environment spins up $n - t$ honest machines that run
the protocol $\Pi$ and one adversarial machine that runs the protocol
$\mathcal{A}$ and represents the $t$ adversarial parties. These machines are
stateful, and so we denote the respective ITM (which can be paused and resumed)
by $P_i$ for the honest parties (running protocol $\Pi$) and by $A$ for the
adversary (running protocol $\mathcal{A}$). The machines are given time
polynomial in $\lambda$ by invoking their initialization with the parameter
$1^\lambda$. During initialization, the adversary
learns of the number of honest parties $n - t$ and adversarial parties $t$.
Importantly, the honest parties do not have this privilege. We
call this setting \emph{permissionless setting}\index{Permissionless} (also
known as the \emph{anonymous byzantine} or \emph{open setting}), because honest
parties are not informed of each others' identities nor their count. Contrary to
our treatment throughout this thesis, there also exists a
\emph{permissioned}~\cite{consensus-sok} setting in the blockchain literature.
In that setting, the $n$ nodes are given authenticated channels between each
other and the quantity $n$ is known to all parties. We will not make this
assumption here. The fact that we are working in the permissionless setting
gives rise to the \emph{decentralized}\index{Decentralized} title of this
thesis.

Time is quantized into discrete \emph{rounds}\index{Round}\index{Slot} (or \emph{slots}) numbered $r = 1, 2, 3, \cdots$.
The
environment contains a main loop which executes one iteration per round $r$ for
a total polynomial number of rounds $p(\lambda)$. During
every round, it first activates every honest party $P_i$ by invoking its
\textsf{execute} method. Subsequently, at the end of
the round, it actives the adversary $A$. The fact that the adversary is activated at
the end of every round is an advantage for the adversary. We call such an
adversary a \emph{rushing adversary}\index{Rushing Adversary}, because it can use its computational power
for the round after it has observed what the honest parties have done during the
same round. Both the honest party and the adversary can know the index of the
current round by counting how many times they have been activated so far in
their persistent state. Because both the honest parties and the
adversary are PPT machines, they will run for polynomial time every time they
are activated. Additionally, we assume $n$ is polynomial, thus ensuring the
total execution time is polynomial.

\subsection{The Network}

When an honest party is activated, it is given messages from the network to
\emph{read}, which are written to a special location within its input tape by
the environment. Here, we denote the network messages received by party $i$ as
$\overline{C}[i]$ and pass them as input to the \textsf{execute} method. The
party can then \emph{write} messages to the network during the round, which we
denote by the \textsf{execute} method returning a value. We say that such
messages are \emph{diffused}\index{Diffuse} to the network. At the end of the
round, the adversary can see all the messages $C$ that have been diffused by the
honest parties during the same round. The adversary can then decide what will
appear in the network tape of every honest party at the beginning of the next
round by outputting an array $\overline{C}$ that contains a list of messages
$\overline{C}[i]$ for every party $i$. The adversary can reorder the messages and
insert as many of her own as she wishes. That is, it is possible that
$\overline{C}[i]$ will contain more messages than $\overline{C}$ and that the
messages in $\overline{C}[i]$ will appear in a different order than in
$\overline{C}$.

However, she must ensure that all messages diffused by any honest party
during the previous round appear in the network tape of every other honest party
at the beginning of the next round. This is ensured by the assertion in Line~\ref{alg.environment.connectivity}. This means that no messages can be dropped
by the adversary. This \emph{connectivity} assumption is equivalent to assuming
that each honest party is not \emph{eclipsed}~\cite{eclipse,eclipse-ethereum}\index{Eclipse}
from the rest of the network. In practice, this is achieved by ensuring that
every honest party is connected to every other honest party through some path,
although not necessarily directly. Practical peer-to-peer protocols use
gossiping~\cite{gossip}\index{Gossip} to ensure messages reach every participant of the network. The network
model abstracts out such details and treats a round as the unit time which is
needed for a message to reach from every honest party to every other honest
party.

Crucially, because the adversary can reorder messages and inject as many
additional messages as she pleases, she is a
\emph{sybil adversary}~\cite{sybil}\index{Sybil Attack}. This means that the adversary can fake
multiple identities and pretend to produce messages by multiple parties,
potentially more than $t$. It will be the job of our honest protocol to produce
a \emph{sybil resilient} mechanism in which such attacks have no impact on the
protocol's security. Furthermore, the adversary can \emph{split} the view of the
honest parties because she can communicate different messages to different
honest parties and have $C[i] \neq C[j]$ for $i \neq j$ on the same round. For example, the order in which messages are delivered can be
different for every honest party and the adversary may inject different messages
of her own for every honest party.

The requirement that messages diffused at the end of one round are delivered at
the beginning of the next is the \emph{synchronous model}\index{Synchronous}. A
large part of our analysis will be made there.

A relaxation of the synchronous model is the $\Delta$-synchronous model. In this
model, the adversary may delay messages up to $\Delta$ rounds.

Chapters~\ref{chapter:work},
\ref{chapter:stake}, \ref{chapter:superlight}, \ref{chapter:sidechains} are
explored in the synchronous model. Our results extend to the $\Delta$-bounded
delay model. We explore these extensions in Chapter~\ref{chapter:variable}.

\subsection{Synchrony and Adaptivity}
\todo{Expand this subsection}

\subsubsection{The Synchronous and Bounded Delay Setting}

We employ the model from~\cite{praos}, which is in turn based
on~\cite{ouroboros} and~\cite{backbone}.
The formalization we use below captures both synchronous and semi-syn\-chronous
communication; as well as both semi-adaptive and fully adaptive corruptions.

\subsubsection{(Semi-)Adaptive Corruptions}
\label{sec:prelim-corr}

The adversary  influences the protocol execution by interacting
with the available functionalities, and by corrupting parties.
The adversary can only corrupt a party $\party_i$ if it is given
permission by the environment $\env$ running the protocol execution (captured as
a special message from $\env$ to $\adv$).
%The
%permission is in the form of a message $(\mathsf{Corrupt}, \party_i)$ which is
%provided to the adversary by the environment.
Upon receiving permission from the environment, the adversary
corrupts $\party_i$ after a certain delay of $\cordelay$ slots, where $\cordelay$ is
a parameter of our model. In particular, if $\cordelay=0$ we talk about
\emph{fully adaptive corruptions} and the corruption is immediate.
The model with $\cordelay>0$ is
referred to as allowing \emph{$\cordelay$-semi-adaptive corruptions} (as opposed to the
\emph{static corruptions model}, where parties can only be corrupted before the
start of the execution).
%
A corrupted
party $\party_i$ will relinquish its entire state to~$\adv$;
from this point on, the adversary will be activated in place of the
party $\party_i$.

\subsubsection{(Semi-)Synchronous Communication}
\label{sec:prelim-comm}

We employ the ``Delayed Diffuse'' functionality $\DelDiff_\Delta$ given in~\cite{praos} to
model (semi-)synchronous communication among the parties. It allows each party
to diffuse a message once per round, with the guarantee that it will be
delivered to all other parties in at most $\Delta$ slots (the delay within this
interval is under adversarial control). The adversary can also read and reorder
all messages that are in transit, as well as inject new messages.
We provide a detailed description of the functionality $\DelDiff_\Delta$ in
Appendix~\ref{app:diffuse} for completeness.

We refer to the setting where honest parties communicate via $\DelDiff_\Delta$
as the \emph{$\Delta$-semi-synchronous setting} and sometimes omit $\Delta$ if
it is clear from the context. The special case of $\Delta=0$ is referred to as
the \emph{synchronous setting}.
