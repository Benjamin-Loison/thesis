\subsection{Signatures}
A \emph{digital signature}\index{Signature} allows parties to authenticate the origin of a
message as well as its integrity~\cite{katz}. If Alice signs a message $m$, she generates a
signature $\sigma$ which is uniquely associated with that message. That
signature can then only be used to verify that particular message. In a secure signature scheme, an adversary
cannot \emph{forge} signatures that correctly verify for messages that have not
been signed by the honest party.

Signing and verification are two separate tasks which are asymmetric. Only the
authorized party can sign a message, but anyone can verify the signature. This
is achieved by having each party generate their own \emph{public-private
key pair} $(pk, sk)$ in which $pk$ is the public key and $sk$ is the secret key.
Signatures are then generated using the secret (or signing) key $sk$ and
verified using the public (or verification) key $sk$. A key pair is generated
using the polynomial-time key generation algorithm $(pk, sk) \gets
\Gen(1^\lambda)$. A signature is generated by invoking the polynomial-time
signing algorithm $\sigma = \Sig(sk, m)$. Verification is done by checking
whether the verification algorithm $\Ver(pk, m, \sigma)$ returns $\true$ or
$\false$. The signature scheme $\Pi$ then is defined as the tuple
$\Pi = (\Gen, \Sig, \Ver)$.

Signature schemes must be \emph{correct}.

\begin{definition}[Signature correctness]
  A signature scheme is \emph{correct} if there is a
  negligible function $\negl$ such that for all messages $m \in \{0, 1\}^*$ it
  holds that

  \[
    \Pr[(pk, sk) \gets \Gen(1^\lambda); \Ver(pk, m, \Sig(sk, m)) = \false] < \negl(\lambda)\,.
  \]
\end{definition}

A \emph{secure} signature scheme requires that no adversary is able to forge
signatures. This is captured in the game-based definition of Algorithm~\ref{alg.forgery}\index{Existential Forgery}. In this game, the challenger first generates a public/private key pair by invoking $\Gen(1^\lambda)$. Subsequently, the challenger asks the adversary $\mathcal{A}$ to attempt to find a signature forgery. The adversary is allowed to ask the challenger to have any messages signed by invoking the ${\Sig}O$ oracle with messages of her choice. The adversary is allowed to make multiple adaptive queries to the oracle. When the adversary is ready, she presents a message $m$, which she must not have requested from the oracle ${\Sig}O$ and a signature $\sigma$. The adversary is successful if the signature verifies.

\input{./chapters/background/algorithms/alg.forgery.tex}

\begin{definition}[Security]
  A signature scheme $\Pi = (\Gen, \Sig, \Ver)$ is \emph{secure} if for all PPT adversaries $\mathcal{A}$ there is a negligible function $\negl$ such that

  \[
  \Pr[\textsc{sig-forge}_{\Pi,\mathcal{A}}(\lambda)] < \negl(\lambda)\,.
  \]
\end{definition}

There are multiple ways to construct a secure signature scheme. Our signature schemes of interest make use of the \emph{discrete logarithm} problem in a group. In such a construction, a cyclic group $\mathbb{G}$ with order close to $2^\lambda$ and a generator $G \in \mathbb{G}$ are fixed initially. A public key corresponds to an element $A \in G$ of the group, while the corresponding private key $a \in \mathbb{Z}_{|\mathbb{G}|}$ is the order of $A$ with respect to $G$, that is $A = aG$. The keys are generated by first choosing a private key $a$ uniformly at random and then computing its corresponding public key. The public key can be computed quickly from the private key using multiplication by doubling~\cite{shoup}, but it is believed that the inverse problem is hard.

The problem of finding $a$ from $A$ is made formal in Algorithm~\ref{alg.dlog}. Here, we assume that an efficient algorithm $\mathcal{G}$ can be used to pick a suitable group of the appropriate order and output its description. Furthermore, we assume the group operator is efficiently computable. The challenger generates a group and chooses one of its elements at random. The adversary is then asked to find the \emph{discrete logarithm} of that element.

\input{./chapters/background/algorithms/alg.dlog.tex}

\begin{definition}[Discrete Logarithm Problem]\index{Discrete Logarithm}
  The \emph{discrete logarithm problem} is hard in the family of groups $\{\mathcal{G}(1^\lambda)\}_{\lambda \in \mathbb{N}}$ if for all PPT adversaries $\mathcal{A}$ there is a negligible function $\negl$ such that

  \[
    \Pr[\textsf{DLOG}_{\mathcal{G},\mathcal{A}}(\lambda) = 1] < \negl(\lambda)\,.
  \]
\end{definition}

The particular instantiation of signature schemes in the context of
cryptocurrencies makes use of elliptic curves~\cite{ec} in which the discrete logarithm problem is believed to be hard. More specifically, Bitcoin
and Ethereum both use the \texttt{secp256k1} curve~\cite{secp256k1}\index{secp256k1}.

\begin{remark}
We remark that, perhaps contrary to popular belief, blockchain protocols
do not depend at all on encryption primitives. Therefore, we choose not to
treat encryption at all in the present work.
\end{remark}
