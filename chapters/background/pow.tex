\subsection{Proof-of-Work}
In our decentralized systems in which the number of participants is unknown and
their channels remain unauthenticated, we will assume that the \emph{majority}
of the population is honest~\cite{backbone}. This assumption is summarized in
the following equation:

\begin{definition}[Honest Majority Assumption]\index{Honest Majority}\index{$\delta$}
  We say that a population has \emph{honest majority} if

  \[
  t \leq (1 - \delta)(n - t)
  \]
\end{definition}

This mandates that the number of adversarial parties $t$ is less than the honest
parties $n - t$ by a fraction determined by the parameter $\delta$, the
\emph{honest advantage}\index{Honest Advantage}. We will refer to
this model as the $\frac{1}{2}$-adversary. This assumption is generally
necessary to solve the consensus problem in polynomial time~\cite{okun},
although it can be temporarily relaxed~\cite{dishonest}. Throughout this
work, we will assume that the honest majority holds during \emph{all} rounds.

In some cases, most notably in our constructions of
Chapter~\ref{chapter:variable}, our results will be limited to weaker
adversaries that satisfy more stringent assumptions and are bounded by
$\frac{1}{3}$ or $\frac{1}{4}$ as defined below:

\begin{definition}[Bounded adversaries]
  We say that a population has a $\phi$-bounded adversary (where $\phi$
  typically takes the values of $\frac{1}{2}$, $\frac{1}{3}$, or $\frac{1}{4}$)
  for some $0 < \phi \leq \frac{1}{2}$ if

  \[
  \frac{t}{n - t} \leq (1 - \delta)\phi
  \]
\end{definition}

The honest majority assumption denotes a $\frac{1}{2}$-bounded adversary. If the
number of parties changes from round to round, the respective assumption must be
maintained throughout the whole execution.

While theoretically the honest majority assumption discusses population counts,
in practice this is translated into a majority in computational power. To
achieve this in our model, we bound the number of Random Oracle queries which
are allowed per party per round by some constant $q > 0$, which is the same for all
parties. Limited computational power is then captured by the limited number of
queries to the Random Oracle. As such, each honest party has $q$ available
queries per round, for a total of $(n - t)q$ queries per round, while the
adversary has $tq$ available queries per round. We call this model the
\emph{$q$-bounded model}\index{$q$-bounded Model}.

When working in the synchronous setting, we will set $q$ to be some polynomial
of the security parameter. As the queries are counted \emph{per round}, the
model captures the fact that up to $q$ queries can be made prior to an honest
party being able to communicate the result of their query to the rest of the
honest parties. In the $\Delta$-bounded delay setting, we will simplify by
setting $q = 1$, as the number of queries allowed before a message reaches the
rest of the network can be controlled by adjusting $\Delta$. Concretely, we note
that a $\Delta$-bounded delay setting with $q > 1$ is captured by an equivalent
model in which $\Delta' = \Delta + q$ and $q' = 1$.

The honest parties try to distinguish between messages diffused by the other
honest parties and the adversary. This is a form of \emph{voting}. The parties
vote on a message $m$ by solving the \emph{proof-of-work equation}~\cite{pow}
which is defined as follows.

\begin{definition}[Proof-of-Work]\index{Proof-of-Work}\index{Target}
  Consider a hash function $H: \{0, 1\}^* \rightarrow \{0, 1\}^\kappa$ and some
  $T \leq 2^\kappa$.
  A nonce
  $ctr \in \{0, 1\}^*$ is called \emph{proof-of-work}
  for message $m \in \{0, 1\}^*$ against \emph{target} $T$ if the following inequality
  holds:

  \[
  H(m \concat ctr) \leq T
  \]
\end{definition}

If $H$ is modelled as a Random Oracle,
the best way to solve proof-of-work for a previously unseen message $m$ is by
brute force: iterate through all possible $ctr$ values until a solution is
found.
The message $m$ must have sufficient entropy to ensure no other party is looking
for proof-of-work for the same message. The algorithm that looks for
a proof-of-work solution, given $q$ queries available in a round, is illustrated
in Algorithm~\ref{alg.pow}.

\input{chapters/background/algorithms/alg.pow}

This makes the proof-of-work problem of
finding a nonce a \emph{moderately hard} problem. In the extreme case
where $T = 1$, the problem is computationally hard and lies in $\textsc{EXP}$,
as it takes an exponential number of random oracle queries to find the value
required.
On the other end, if $T = 2^{\kappa-1}$, the problem is computationally easy and
lies in $\textsc{P}$, as only a single query is required to solve the problem
in expectation. When $T$ takes a moderate value, the problem requires a moderate
number of queries until a solution is found. Crucially, the expected number of
queries can be controlled by adjusting the target parameter $T$. Proof-of-work
has the property that it is moderately hard to find, but once found it can be
easily verified by checking that the equation holds.

\begin{definition}[Successful Query]\index{Successful Query}
We call a query to the Random Oracle that satisfies
the proof-of-work equation a \emph{successful query}.
\end{definition}

\begin{lemma}[Successful Query]\index{p}
The probability of a new query being successful $p = \frac{T}{2^\kappa}$.
\end{lemma}

We now define the random variables $X_r$, $Y_r$ that specify whether a round
was \emph{successful} and \emph{uniquely successful}.

\begin{definition}\index{Successful Round}\index{Uniquely Successful Round}\index{X}\index{Y}
If an honest party has made a successful query during a round $r$, then we call
$r$ a \emph{successful round} and set $X_r = 1$; otherwise, we set $X_r = 0$.
If among the \emph{honest} queries during $r$ only
\emph{one} was successful, we call $r$ a \emph{uniquely successful round}
and we set $Y_r = 1$; otherwise, we set $Y_r = 0$.
\end{definition}

It is of course possible that, in addition to the honest parties, the adversary
could have had successful queries during a successful or uniquely successful
round. The adversary can also succeed in rounds during which the honest parties
were unsuccessful. We let $Z_{rj} = 1$ if during round $r$ the $j^\text{th}$
adversarial query was successful, where $j$ ranges from $1$ to $tq$; otherwise
we let $Z_{rj} = 0$. For a set of rounds $S$, we define
$X(S) = \sum_{r \in S}X_r$ and $Y(S) = \sum_{r \in S}Y_r$ as well as
$Z(S) = \sum_{r \in S}\sum_{j = 1}^{tq} Z_{rj}$.

Naturally, for the $\Delta$-bounded delay setting in which $q = 1$, the variable
$j$ ranges up to $t$. In that model, we also define isolated uniquely successful
rounds as rounds which are uniquely successful and are followed by a silence of
duration $\Delta$.

\begin{definition}[$\Delta$-isolated uniquely successful round]
A round $r$ is \emph{$\Delta$-isolated uniquely successful round} if $Y_r = 1$
and for all $r \leq r' \leq r + \Delta$ it holds that $X_{r'} = 0$.
\end{definition}

In reality, not every honest party has the same computational power, and
multiple honest parties may combine their computational power into a so-called
\emph{mining pool}. These can be captured by treating a more powerful honest
party as multiple honest parties each of which contributes $q$ queries per
round. This is made explicit for the adversary, as she does not incur any
network overhead to achieve communication between the $t$ corrupted parties. On
the contrary, honest players discovering proof-of-work must diffuse it to the
network at a given round and wait for it to be received and validated by the
rest of the honest players at the beginning of the next round (or $\Delta$
rounds later in the $\Delta$-bounded delay model).
