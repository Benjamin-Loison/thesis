\subsection{Hash Functions}\index{Hash}
A hash function $H^s: \mathcal{M} \longrightarrow \{0, 1\}^\lambda$ is a function
parameterized by the security parameter $\lambda$ which takes any string from the distribution of input strings $\mathcal{M}$ and
outputs a string of constant size $\lambda$. To capture the fact that the hash
function behaves like a randomly chosen function, the hash
function is instantiated using a key-generating function
$\textsf{Gen}(1^\lambda)$ which generates a hash key $s$. The hash function itself is then $H^s$, a different function for each value of the key $s$. As hash functions are the building blocks and workhoses of cryptography, other protocols are designed on top of them that make use of them. We will do so in this work. In practice, the key $s$ is assumed to have been generated by the designers of the higher level protocol that makes use of the hash function and is typically fixed and publicly known. The hash protocol is the tuple $\Pi = (\textsf{Gen}, H)$.

Practical hash functions allow us to map any message $x$ of arbitrary length
$x \in \{0, 1\}^*$ to a fixed-length bitstring $\{0, 1\}^\lambda$. Hash
functions are easy to compute, but hard to invert. In applications, it is
assumed that a hash uniquely represents its preimage (it is \emph{binding}) and
that the preimage cannot be discovered from the image given sufficient entropy
(it is \emph{hiding}).

These intuitive ideas are captured by the difficulty of finding
collisions in hash functions. This is formalized in the next definition.

\input{./chapters/background/algorithms/alg.collision-resistance.tex}

\begin{definition}[Collision resistance]\index{Collision Resistance}
  A hash function $H: \{0, 1\}^* \longrightarrow \{0, 1\}^\lambda$ is called
  \emph{collision resistant} if for all PPT adversaries $\mathcal{A}$ there is a
  negligible function $\negl$ such that

  \[
  \Pr[\textsf{hash-collision}_{\Pi,\mathcal{A}} = 1] \leq \negl(\lambda)\,.
  \]
\end{definition}

A weaker notion of security mandates that no adversary can reverse the function (pre-image resistance) or that no adversary can find a second value giving the same output as a given random value. The two cryptographic games and definitions are illustrated in Algorithms~\ref{alg.hash-preimage} and~\ref{alg.hash-second-preimage}.

\input{./chapters/background/algorithms/alg.hash-preimage.tex}
\input{./chapters/background/algorithms/alg.hash-second-preimage.tex}

\begin{definition}[Pre-image resistance]
  A hash function $H: \{0, 1\}^* \longrightarrow \{0, 1\}^\lambda$ is called
  \emph{pre-image resistant} if for all PPT adversaries $\mathcal{A}$ there is a
  negligible function $\negl$ such that

  \[
  \Pr[\textsf{hash-preimage}_{\Pi,\mathcal{A}} = 1] \leq \negl(\lambda)\,.
  \]
\end{definition}

\begin{definition}[Second pre-image resistance]
  A hash function $H: \{0, 1\}^* \longrightarrow \{0, 1\}^\lambda$ is called
  \emph{second pre-image resistant} if for all PPT adversaries $\mathcal{A}$
  there is a negligible function $\negl$ such that

  \[
  \Pr[\textsf{hash-second-preimage}_{\Pi,\mathcal{A}} = 1] \leq \negl(\lambda)\,.
  \]
\end{definition}

A hash function that is collision-resistant is also pre-image resistant; additionally, if it is pre-image resistant, then it must also be second pre-image resistant, as long as it provides sufficient compression~\cite{rogaway2004cryptographic}.

Protocols deployed in practice make use of fixed hash functions; that is, hash
functions with a fixed security parameter and a fixed key. In Bitcoin, the hash
function $\SHA$~\cite{sha256} is used for both commitments and proof-of-work.
Its domain and range are
$\SHA: \{0, 1\}^* \longrightarrow \{0, 1\}^{256}$. In Ethereum, the hash
function $\keccak$~\cite{bertoni2008indifferentiability}, a variant of
$\texttt{SHA3}$, is used for commitments. Its domain and range are $\keccak: \{0, 1\}^*
\longrightarrow \{0, 1\}^{256}$. The function used for proof-of-work is a
variant of this.
