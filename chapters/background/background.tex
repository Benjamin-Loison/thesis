\chapter{Background}\label{chapter:background}

The cryptographic treatment has three core characteristics~\cite{katz}.

\begin{enumerate}
  \item \textbf{Formal definitions} play a central role. They specify the
        desirable properties of our protocols. As we will see, these can often
        be quite tricky to develop. One such example is the definition of
        \emph{pegging security} in Chapter~\ref{chapter:sidechains}.
  \item \textbf{Clearly articulated assumptions} allow us to understand the
        limitations of our protocols. Our protocols never work
        unconditionally, and we must restrict our model to obtain security. One
        such example is the computing power of the adversary. In the case of
        Chapter~\ref{chapter:work}, we can withstand a $1/3$ adversary, but the
        extended model of Chapter~\ref{chapter:variable} can only withstand a
        $1/4$ adversary.
  \item \textbf{Rigorous proofs of security} give us the \emph{guarantee} that
        our protocols are secure, as long as our assumptions hold. Instead of
        employing \emph{ad hoc} arguments, the proofs are mathematical theorems
        employing computational reductions, and they assert that the protocols
        are secure \emph{for all} adversaries.
\end{enumerate}

This chapter gives an overview of prerequisites upon which we build our
protocols. Blockchain science is a new field. As such, many of the elements we
employ here are folklore knowledge in the community, and some of them have never
been written down precisely before. Thus, this chapter may be of independent
interest as reference. Two remarkable examples are the security proof for
Merkle Trees, which to our knowledge has not been written down before, as well
as an explicit description of the static difficulty, variable difficulty,
synchronous, and $\Delta$-bounded delay environments in the form of pseudocode,
which has previously only appeared in imprecise textual descriptions.

\input{chapters/background/notation}

\section{Cryptographic Primitives}

We now overview the cryptographic primitives we will make use of. In particular,
cryptographically secure hash functions, public-key signatures, and
proof-of-work. This section is a review. For a full
treatment, refer to any introductory textbook in the subject~\cite{katz,handbook,foundations1,foundations2}.

\input{chapters/background/hash}
\input{chapters/background/signature}

\todo{Copy lecture notes from our \emph{Introduction to Blockchains} course for the next sections...}

\section{Authenticated Data Structures}
\input{chapters/background/merkle}

\section{Model}
\input{chapters/background/ro}
\input{chapters/background/environment}

\todo{Copy lecture notes from our \emph{Introduction to Blockchains} course for the next sections...}

\section{The Application Layer}
In creating a decentralized cryptocurrency, the goal is to build a monetary
system which is not reliant on any third parties.

Money is moved around by issuing \emph{transactions}, which instruct the
transfer of a certain amount from one party to another. If Alice holds a
certain amount of money and she wishes to give it to Bob, she creates a
transaction which encodes, in some form, the instruction to pay Bob that certain
amount. That transaction is encoded into a string that is then signed by Alice
and transmitted to the network.

Contrary to centrally controlled currencies in which banks or payment processors
are responsible for maintaining balances, decentralized cryptocurrencies allow
any participant to verify the validity of a transaction. In order for this to be
possible, every transaction is transmitted to every interested party on the
network, a so-called \emph{full node}, who validates it. By recording all past
transactions, every participant is aware of \emph{who owns what} and can thereby
determine if an attempt to spend money is legitimate. No special privileged or
trusted nodes exist on the network.

We now formally define what a transaction is and look at the transaction formats
for Bitcoin and Ethereum. In addition to being the largest cryptocurrencies,
these two systems define two prototypal transaction formats known as the
\emph{UTXO model} and the \emph{Account model}. All other cryptocurrencies adopt
either model, or a hybrid of the two~\cite{chimeric}.

\subsection{Transactions}
Transactions are part of the
\emph{application layer}\index{Application Layer}. As this thesis concerns
itself with the \emph{consensus layer} which organizes transactions into
sequences, we will generally not concern ourselves about their format, and we
will allow the application layer to specify any transaction format it wishes.
Therefore, transactions can be any strings that are deemed valid by the
application layer.

\begin{definition}[Transaction]\index{Transaction}
  A predefined language $\Trans$ of strings in $\{0, 1\}^*$ is called
  a \emph{transaction language}. Elements $tx \in \Trans$ are called
  \emph{transactions}.
\end{definition}

While specific applications such as Bitcoin or Ethereum mandate that
transactions follow a certain format and must include, for example, signatures,
we will not impose such requirements on our protocol. As there are
preconceptions about what constitutes a transaction, we feel the need to give
some examples of transaction languages. The set of valid transactions could be
the empty set, the set $\{0, 1\}$ of bits, the set of natural numbers, or the
set of triplets of a message, a public key, and a digital signature that pass
verification under a certain signature scheme. While the latter corresponds more
closely to practical protocols such as Bitcoin, our treatment is quite general
and has no requirements to remain within this strict format.

Once the set of valid transactions $\Trans$ has been defined by the
application layer, it can now specify a \emph{validity language} which specifies
which \emph{sequences} of transactions are valid. This captures what is deemed
to be a valid transaction given a previous history of transactions in the
system and allows the application layer to specify, for example, that double
spending is not allowed.

\begin{definition}[Validity Language]\index{Validity Language}
  Given a transaction language $\Trans$, a predifined set of finite
  transaction sequences $\ValLang \subseteq \Trans^*$ is called its
  \emph{validity language}.
\end{definition}

The validity languages we will concern ourselves with have the property that
they contain the empty transaction sequence $\epsilon$. This is useful because
it allows a node booting up anew to begin with an empty transaction sequence
before it starts receiving and validating transactions. Our validity languages
are also \emph{extensible}: Given a valid transaction sequence $\overline{\tx}
\in \ValLang$ and a new candidate transaction $\tx \in \Trans$, it is
possible to check whether $\overline{\tx} \concat \tx \in \ValLang$ by applying
a predicate $\textsf{extend}(\overline{\tx}, \tx)$. This $\textsf{extend}$
predicate ensures that the transaction only spends money that belongs to it and
exists in the system. Furthermore, once a
transaction which invalidates the sequence has been added to the sequence, the
sequence remains invalid.

In addition to allowing transactions that spend existing money, it must be
possible to also create new money. The macroeconomic rules for money creation
are captured by another application-specific predicate
$\textsf{mints}(\overline{\tx}, \tx)$ which checks whether a transaction $\tx$
is a valid minting transaction. The rules for this can include, for example,
limiting the amount of money generated per block.
In typical cryptocurrencies, there is one minting transaction allowed per block
and the amount that can be generated by this minting transaction has an
upper bound which is algorithmically determined~\cite{equitability}.
We will leave this predicate undefined in our treatment.

Validity by extension is captured by the definition below:

\begin{definition}[Validity by extension]\label{def:lang-extension}
  Given an extension predicate $\textsf{extends}$, and a transaction language
  $\Trans$, the validity language
  $\ValLang^{\textsf{extends},\textsf{mints},\Trans}$ obtained \emph{by extension} is
  the minimum set of transaction sequences which satisfies the following:

  \begin{enumerate}
    \item \textbf{Base.}
          $\epsilon \in \ValLang^{\textsf{extends},\Trans}$
    \item \textbf{Extension.}
          For all $\overline{\tx} \in \ValLang^{\textsf{extends},\textsf{mints},\Trans}$, for all
          $\tx \in \Trans$, if
          $\textsf{extends}(\overline{\tx}, \tx)$ or $\textsf{mints}(\overline{\tx}, \tx)$ then
          $\overline{\tx} \concat \tx \in \ValLang^{\textsf{extends},\textsf{mints},\Trans}$.
  \end{enumerate}
\end{definition}

From the above definition, the following result follows immediately.

\begin{lemma}[Validity Language Monotonicity]
  Consider a validity language $\ValLang$ generated \emph{by extension} of a
  transaction language $\Trans$. For all $w,w'\in \Trans^*$ we have
  $w\not\in\ValLang \Rightarrow w\concat w'\not\in\ValLang$.
\end{lemma}

Monotonicity mandates the natural property that if a sequence of transactions is
invalid, it cannot become valid again by adding further transactions.

Furthermore, it is useful to ensure transactions are unique. This is captured in
the following requirement for the validity languages of our interest.

\begin{definition}[Validity Language Transaction Uniqueness]\label{def:trans-uniqueness}
  A validity language $\ValLang$ pertaining to a transaction language $\Trans$
  has \emph{transaction uniqueness} if it never contain the same transaction
  twice: for any $\tx\in \Trans$ and any
  $w_1,w_2,w_3\in \Trans^*$ we have

  \[ w_1\concat\tx\concat
  w_2\concat\tx\concat w_3\not\in\ValLang \,~. \]
\end{definition}

The natural ``uniqueness'' property of transactions in existing implementations
is not necessary for our treatment, but it allows for some simplifications.

For illustrative purposes, and because we aim our protocols to be deployable to
existing blockchain systems, in particular to Bitcoin-compatible and
Ethereum-compatible chains, we now explore two particular approaches to the
transaction and validity languages employed in the blockchain space: the UTXO
model and the Account model. We note, however, that our consensus protocols
which enable compression and interoperability are not limited to these two
models, but are generic.

\section{Blockchains}
\subsection{The Consensus Problem}
\subsection{Proof-of-Work}
\cite{pow}\index{Proof-of-Work}
The
honest parties try to distinguish between messages diffused by the other honest
parties and the adversary.

\subsection{Blocks}
genesis
\subsection{Chains of Blocks}
longest chain rule
\subsection{Blockchain Addressing}
\subsection{SPV}
the p2p network and types of nodes: full nodes, SPV nodes, ...

\section{Forks}
\subsection{Hard Forks}
\subsection{Soft Forks}

\section{Cryptocurrencies}
\subsection{Bitcoin}
\subsection{Ethereum}

\section{Smart Contracts}
\subsection{Bitcoin Script}
\subsection{Solidity}

\input{chapters/background/math}
\section{Blockchain Protocols}

In our treatment, we deal with the \emph{consensus layer}\index{Consensus Layer}
of the protocol. The consensus layer attempts to organize
\emph{application layer} transactions into sequences that belong to the
application's validity language by ordering them into a ledger.

\begin{definition}[Ledger]\index{Ledger}
\end{definition}

\begin{description}
  \item[Persistence.]\index{Persistence}
    For any two honest parties $\party_1,\party_2$ and two rounds $r_1\leq r_2$,
    it holds  $\LView{\Ledger}{\party_1}{r_1} \preceq
    \LView{\check{\Ledger}}{\party_2}{r_2}$.

  \item[Liveness.]\index{Liveness}
    If all honest parties in the system attempt to include a  transaction
    then, at any round $t$ after $u$ rounds (called the
    liveness parameter), any honest party $\party$, if queried,
    will report $\tx \in \LView{\Ledger}{\party}{r}$.
\end{description}


\subsection{Blockchain Backbone}
\todo{Restore old NIPoPoWs paper backbone overview section}

\todo{fix citations}\cite{backbone,pass-asynchronous,varbackbone}

The Bitcoin Backbone protocol is illustrated in Algorithm~\ref{alg.backbone}.

\input{chapters/background/algorithms/alg.backbone}

\begin{remark}[Impossibility of full semi-synchrony]
Revisiting the $\Delta$-bounded delay model, a folklore observation that has not appeared in
the litature is that blockchain protocols are impossible to obtain in the fully
semi-synchronous setting where \emph{no} conditions are imposed on $\Delta$,
because of the anonymous nature of the model. This impossibility stems from the
fact that $n$ is unknown to the honest parties. To see this, consider an
honest majority execution in which an adversary controls $t = (1 - \delta)(n -
t)$ parties for some $\delta > 0$. If the honest parties take a decision of
transaction acceptance within some time $\Delta$, then that $\Delta$ can be used
as network delay in which the messages of a percentage larger than $\delta$ of
the honest parties are delayed. That setting is then indistinguishable to the
honest parties from a setting in which the adversary controls the majority of
the parties $t > n - t$, as there is an honest percentage which is effectively
eclipsed. This is the case regardless of which solution is used to approach the
problem of consensus -- whether it is through blockchains or other means.
Standard dishonest majority attacks therefore become possible avenues to break
the protocol. Hence, the $\Delta$-bounded delay setting in which $\Delta$ is
unknown but some conditions are imposed on it is the best possible model we can
hope for, as further relaxation would not allow for a solution, as long as
dishonest majority breaks the protocol. The model can only be improved by
relaxing the conditions.
\end{remark}

\todo{fast and slow blocks}

% Honest Majority Assumption
% Chain Growth
% Common Prefix
% Chain Quality
% The Constant Difficulty assumption and its relaxation
\subsection{The Common Reference String}
\todo{Move Proof-of-Burn paper appendix notes here}

% Mention that CRS is not needed (due to Bootstrapping the Blockchain - Directly paper)
% Epochs
\input{chapters/background/ouroboros}
