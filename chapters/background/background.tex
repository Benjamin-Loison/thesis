\chapter{Background}\label{chapter:background}

The cryptographic treatment has three core characteristics~\cite{katz}.

\begin{enumerate}
  \item \textbf{Formal definitions} play a central role. They specify the
        desirable properties of our protocols. As we will see, these can often
        be quite tricky to develop. One such example is the definition of
        \emph{pegging security} in Chapter~\ref{chapter:sidechains}.
  \item \textbf{Clearly articulated assumptions} allow us to understand the
        limitations of our protocols. Our protocols never work
        unconditionally, and we must restrict our model to obtain security. One
        such example is the computing power of the adversary. In the case of
        Chapter~\ref{chapter:work}, we can withstand a $1/3$ adversary, but the
        extended model of Chapter~\ref{chapter:variable} can only withstand a
        $1/4$ adversary.
  \item \textbf{Rigorous proofs of security} give us the \emph{guarantee} that
        our protocols are secure, as long as our assumptions hold. Instead of
        employing \emph{ad hoc} arguments, the proofs are mathematical theorems
        employing computational reductions, and they assert that the protocols
        are secure \emph{for all} adversaries.
\end{enumerate}

This chapter gives an overview of prerequisites upon which we build our
protocols. Blockchain science is a new field. As such, many of the elements we
employ here are folklore knowledge in the community, and some of them have never
been written down precisely before. Thus, this chapter may be of independent
interest as reference. Two remarkable examples are the security proof for
Merkle Trees, which to our knowledge has not been written down before, as well
as an explicit description of the static difficulty, variable difficulty,
synchronous, and $\Delta$-bounded delay environments in the form of pseudocode,
which has previously only appeared in imprecise textual descriptions.

\input{chapters/background/notation}

\section{Cryptographic Primitives}

We now overview the cryptographic primitives we will make use of. In particular,
cryptographically secure hash functions, public-key signatures, and
proof-of-work. This section is a review. For a full
treatment, refer to any introductory textbook in the subject~\cite{katz,handbook,foundations1,foundations2}.

\input{chapters/background/hash}
\input{chapters/background/signature}

\section{Authenticated Data Structures}
\input{chapters/background/merkle}

\section{Model}
\input{chapters/background/ro}
\input{chapters/background/environment}

\todo{Copy lecture notes from our \emph{Introduction to Blockchains} course for the next sections...}

\input{chapters/background/application}

\section{Blockchains}
\input{chapters/background/consensus}
\input{chapters/background/pow}

\subsection{Blocks}
genesis

\todo{continuity}

Blockchains are finite
block sequences obeying the \emph{blockchain property}: that in every block in
the chain there exists a pointer to its previous block. A chain is
\emph{anchored} if its first block is \emph{genesis}, denoted $Gen$.
Given chains $\chain_1, \chain_2$ and blocks $A, Z$ we concatenate them as
$\chain_1 \chain_2$ or $\chain_1 A$. $\chain_2[0]$ must point to $\chain_1[-1]$
and $A$ must point to $\chain_1[-1]$.
The \emph{id} function
returns the id of a block given its data, i.e., $\textsf{id} = H(ctr, G(x,
\textsf{interlink}))$.

\subsection{Chains of Blocks}
longest chain rule
\subsection{Blockchain Addressing}
\subsection{SPV}
the p2p network and types of nodes: full nodes, SPV nodes, ...

\section{Forks}
\subsection{Hard Forks}
\subsection{Soft Forks}

\section{Smart Contracts}
\subsection{Bitcoin Script}
\subsection{Solidity}

\input{chapters/background/math}
\section{Blockchain Protocols}

\subsection{Blockchain Backbone}
\todo{Restore old NIPoPoWs paper backbone overview section}

\todo{fix citations}\cite{backbone,pass-asynchronous,varbackbone}

The Bitcoin Backbone protocol is illustrated in Algorithm~\ref{alg.backbone}.

\input{chapters/background/algorithms/alg.backbone}

\todo{Continuity}

Chains maintained by honest parties running the backbone protocol in an honest
majority setting satisfy the following three properties.

The \emph{chain growth} property states that the chain of an honest party will
keep growing at a certain rate $\tau$. Because honest parties always extend the
longest chain, this property holds even in executions of dishonest majority.

\begin{definition}[Chain Growth]\index{Chain Growth}
  An execution has \emph{chain growth} with parameters $\tau \in \mathbb{R}$
  (the \emph{chain velocity}) and $s \in \mathbb{N}$ if for all honest parties
  $\party$ and for all rounds $r$ the following holds. If $\party$ has adopted
  chain $\chain$ at round $r$, then for every round $r' > r + s$ the chain
  $\chain'$ adopted by $\party$ at round $r'$ satisfies:

  \[
  |\chain'| \geq |\chain| + \tau s
  \,.
  \]
\end{definition}

The \emph{chain quality} property states that any large enough ($\geq s$) chunk
of an honestly adopted chain will always contain some ($\rho$) honest blocks.

\begin{definition}[Chain Quality]\index{Chain Quality}
  An execution has \emph{chain quality} with parameters $\rho$ (the
  \emph{chain quality parameter}) and $s \in \mathbb{N}$ if for all honest
  parties $\party$ and for all rounds $r$ during which the party has adopted
  chain $\chain$ the following holds. For any $i, j$ such that
  $|\chain[i:j]| = s$,
  the block set
  $\chain' = \{B \in \chain[i{:}j]: B \text{ was honestly generated}\}$ satisfies:

  \[
  \frac{|\chain'|}{s} \geq \rho
  \,.
  \]
\end{definition}

The \emph{common prefix} property states that the chains of two honest parties
cannot deviate much. In particular, they will share a large common prefix and
can only differ by up to $k$ blocks near their ends.

\begin{definition}[Common Prefix]\index{Common Prefix}
  An execution has \emph{common prefix} with parameter $k$ (the \emph{common
  prefix parameter}) if for all honest parties $\party_1, \party_2$ and rounds
  $r_1 \leq r_2$ the following holds. If $\party_1$ has adopted $\chain_1$
  during round $r_1$ and $\party_2$ has adopted $\chain_2$ during round $r_2$,
  then:

  \[
  \chain_1[{:}-k] \preceq \chain_2
  \,.
  \]
\end{definition}

\begin{remark}[Impossibility of full semi-synchrony]
Revisiting the $\Delta$-bounded delay model, a folklore observation that has not appeared in
the litature is that blockchain protocols are impossible to obtain in the fully
semi-synchronous setting where \emph{no} conditions are imposed on $\Delta$,
because of the anonymous nature of the model. This impossibility stems from the
fact that $n$ is unknown to the honest parties. To see this, consider an
honest majority execution in which an adversary controls $t = (1 - \delta)(n -
t)$ parties for some $\delta > 0$. If the honest parties take a decision of
transaction acceptance within some time $\Delta$, then that $\Delta$ can be used
as network delay in which the messages of a percentage larger than $\delta$ of
the honest parties are delayed. That setting is then indistinguishable to the
honest parties from a setting in which the adversary controls the majority of
the parties $t > n - t$, as there is an honest percentage which is effectively
eclipsed. This is the case regardless of which solution is used to approach the
problem of consensus -- whether it is through blockchains or other means.
Standard dishonest majority attacks therefore become possible avenues to break
the protocol. Hence, the $\Delta$-bounded delay setting in which $\Delta$ is
unknown but some conditions are imposed on it is the best possible model we can
hope for, as further relaxation would not allow for a solution, as long as
dishonest majority breaks the protocol. The model can only be improved by
relaxing the conditions.
\end{remark}

\todo{fast and slow blocks}

% Honest Majority Assumption
% Chain Growth
% Common Prefix
% Chain Quality
% The Constant Difficulty assumption and its relaxation
\subsection{The Common Reference String}
\todo{Move Proof-of-Burn paper appendix notes here}

% Mention that CRS is not needed (due to Bootstrapping the Blockchain - Directly paper)
% Epochs
\input{chapters/background/ouroboros}
